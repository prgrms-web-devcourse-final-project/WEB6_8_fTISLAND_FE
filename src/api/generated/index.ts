/**
 * Generated by orval v7.13.2 🍺
 * Do not edit manually.
 * 뭐든배달 API 명세서
 * 뭐든배달 API 명세서입니다
 * OpenAPI spec version: v1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AccountInfoUpdateRequest,
  AddressCreateRequest,
  AddressUpdateRequest,
  ApiResponseAddressResponse,
  ApiResponseAvailableProfilesResponse,
  ApiResponseBoolean,
  ApiResponseCreateProfileResponse,
  ApiResponseCurrentDeliveringDetailsDto,
  ApiResponseCursorPageResponseOrderResponse,
  ApiResponseCursorPageResponseProductResponse,
  ApiResponseCursorPageResponseStoreSearchResponse,
  ApiResponseCustomerProfileResponse,
  ApiResponseDeliveredSummaryResponseDto,
  ApiResponseGeneratePresignedUrlResponse,
  ApiResponseListAddressResponse,
  ApiResponseListCurrentDeliveringResponseDto,
  ApiResponseListNotification,
  ApiResponseListOrderResponse,
  ApiResponseListSettlementResponse,
  ApiResponseListStoreCategoryResponse,
  ApiResponseLoginResponse,
  ApiResponseLong,
  ApiResponseOrderCreateResponse,
  ApiResponseOrderResponse,
  ApiResponsePasswordResetVerifyResponse,
  ApiResponseProductDetailResponse,
  ApiResponseProductResponse,
  ApiResponseReviewCreateResponse,
  ApiResponseReviewLikeResponse,
  ApiResponseReviewRatingAndListResponseDto,
  ApiResponseReviewResponse,
  ApiResponseRiderProfileResponse,
  ApiResponseSellerProfileResponse,
  ApiResponseSettlementResponse,
  ApiResponseSignupResponse,
  ApiResponseStoreResponse,
  ApiResponseString,
  ApiResponseSummaryResponse,
  ApiResponseSwitchProfileResponse,
  ApiResponseTodayDeliveringResponseDto,
  ApiResponseUserInfoResponse,
  ApiResponseVoid,
  BusinessInfoUpdateRequest,
  ChangePasswordRequest,
  CreateProfileRequest,
  CustomerProfileUpdateRequest,
  DeliveryAreaRequestDto,
  GeneratePresignedUrlRequest,
  GetAllParams,
  GetCompletedOrdersParams,
  GetMyReviewsParams,
  GetNotificationsParams,
  GetOrdersHistoryParams,
  GetPeriodSettlements1Params,
  GetPeriodSettlementsParams,
  GetStoreReviewsParams,
  GetTotalDeliveriesParams,
  LoginRequest,
  MyEmailVerifyRequest,
  OrderCancelRequest,
  OrderCreateRequest,
  OrderPayRequest,
  PasswordResetConfirmRequest,
  PasswordResetRequest,
  PasswordResetVerifyRequest,
  ProductCreateRequest,
  ProductUpdateRequest,
  ReviewCreateRequest,
  ReviewUpdateRequest,
  RiderAccountInfoUpdateRequest,
  RiderAreaUpdateRequest,
  RiderDecisionRequestDto,
  RiderProfileUpdateRequest,
  RiderStatusUpdateRequest,
  RiderToggleStatusRequestDto,
  SearchProductsParams,
  SearchStoresParams,
  SellerProfileUpdateRequest,
  SignupRequest,
  SseEmitter,
  StoreCreateRequest,
  StoreUpdateRequest,
  SwitchProfileRequest,
  UpdateStatusParams,
  UpdateUserRequest,
  VerificationSendRequest,
  VerificationVerifyRequest,
} from './model';

import { customInstance } from '../orval-mutator';
/**
 * 현재 로그인한 사용자의 상세 정보를 조회합니다.
 * @summary 내 정보 조회
 */
export const getMyInfo = (signal?: AbortSignal) => {
  return customInstance<ApiResponseUserInfoResponse>({ url: `/api/v1/users/me`, method: 'GET', signal });
};

export const getGetMyInfoInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me`] as const;
};

export const getGetMyInfoQueryKey = () => {
  return [`/api/v1/users/me`] as const;
};

export const getGetMyInfoInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyInfoInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyInfo>>> = ({ signal }) => getMyInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyInfo>>>;
export type GetMyInfoInfiniteQueryError = unknown;

export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, Awaited<ReturnType<typeof getMyInfo>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyInfo>>,
          TError,
          Awaited<ReturnType<typeof getMyInfo>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 정보 조회
 */

export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyInfoInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyInfoQueryOptions = <TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyInfo>>> = ({ signal }) => getMyInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getMyInfo>>>;
export type GetMyInfoQueryError = unknown;

export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, Awaited<ReturnType<typeof getMyInfo>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyInfo>>,
          TError,
          Awaited<ReturnType<typeof getMyInfo>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 정보 조회
 */

export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyInfoQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 사용자 이름, 전화번호 등 기본 정보를 수정합니다.
 * @summary 내 정보 수정
 */
export const updateMyInfo = (updateUserRequest: UpdateUserRequest) => {
  return customInstance<ApiResponseUserInfoResponse>({
    url: `/api/v1/users/me`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateUserRequest,
  });
};

export const getUpdateMyInfoMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyInfo>>,
    TError,
    { data: UpdateUserRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof updateMyInfo>>, TError, { data: UpdateUserRequest }, TContext> => {
  const mutationKey = ['updateMyInfo'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMyInfo>>, { data: UpdateUserRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return updateMyInfo(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateMyInfo>>>;
export type UpdateMyInfoMutationBody = UpdateUserRequest;
export type UpdateMyInfoMutationError = unknown;

/**
 * @summary 내 정보 수정
 */
export const useUpdateMyInfo = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyInfo>>,
      TError,
      { data: UpdateUserRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof updateMyInfo>>, TError, { data: UpdateUserRequest }, TContext> => {
  const mutationOptions = getUpdateMyInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 활성화된 판매자 프로필의 상세 정보를 조회합니다.
 * @summary 내 판매자 프로필 조회
 */
export const getMyProfile = (signal?: AbortSignal) => {
  return customInstance<ApiResponseSellerProfileResponse>({ url: `/api/v1/users/me/seller`, method: 'GET', signal });
};

export const getGetMyProfileInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/seller`] as const;
};

export const getGetMyProfileQueryKey = () => {
  return [`/api/v1/users/me/seller`] as const;
};

export const getGetMyProfileInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfileInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile>>> = ({ signal }) => getMyProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile>>>;
export type GetMyProfileInfiniteQueryError = unknown;

export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 판매자 프로필 조회
 */

export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfileInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyProfile>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile>>> = ({ signal }) => getMyProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile>>>;
export type GetMyProfileQueryError = unknown;

export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 판매자 프로필 조회
 */

export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfileQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 판매자 프로필의 닉네임, 프로필 이미지를 수정합니다.
 * @summary 내 판매자 프로필 수정
 */
export const updateMyProfile = (sellerProfileUpdateRequest: SellerProfileUpdateRequest) => {
  return customInstance<ApiResponseSellerProfileResponse>({
    url: `/api/v1/users/me/seller`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: sellerProfileUpdateRequest,
  });
};

export const getUpdateMyProfileMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyProfile>>,
    TError,
    { data: SellerProfileUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMyProfile>>,
  TError,
  { data: SellerProfileUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateMyProfile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMyProfile>>,
    { data: SellerProfileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMyProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyProfileMutationResult = NonNullable<Awaited<ReturnType<typeof updateMyProfile>>>;
export type UpdateMyProfileMutationBody = SellerProfileUpdateRequest;
export type UpdateMyProfileMutationError = unknown;

/**
 * @summary 내 판매자 프로필 수정
 */
export const useUpdateMyProfile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyProfile>>,
      TError,
      { data: SellerProfileUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMyProfile>>,
  TError,
  { data: SellerProfileUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateMyProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 사업자명, 사업자 전화번호를 수정합니다.
 * @summary 사업자 정보 수정
 */
export const updateBusinessInfo = (businessInfoUpdateRequest: BusinessInfoUpdateRequest) => {
  return customInstance<ApiResponseSellerProfileResponse>({
    url: `/api/v1/users/me/seller/business-info`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: businessInfoUpdateRequest,
  });
};

export const getUpdateBusinessInfoMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBusinessInfo>>,
    TError,
    { data: BusinessInfoUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBusinessInfo>>,
  TError,
  { data: BusinessInfoUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateBusinessInfo'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBusinessInfo>>,
    { data: BusinessInfoUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateBusinessInfo(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBusinessInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessInfo>>>;
export type UpdateBusinessInfoMutationBody = BusinessInfoUpdateRequest;
export type UpdateBusinessInfoMutationError = unknown;

/**
 * @summary 사업자 정보 수정
 */
export const useUpdateBusinessInfo = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBusinessInfo>>,
      TError,
      { data: BusinessInfoUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBusinessInfo>>,
  TError,
  { data: BusinessInfoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateBusinessInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 은행명, 계좌번호, 예금주를 수정합니다.
 * @summary 정산 계좌 정보 수정
 */
export const updateAccountInfo = (accountInfoUpdateRequest: AccountInfoUpdateRequest) => {
  return customInstance<ApiResponseSellerProfileResponse>({
    url: `/api/v1/users/me/seller/account-info`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: accountInfoUpdateRequest,
  });
};

export const getUpdateAccountInfoMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccountInfo>>,
    TError,
    { data: AccountInfoUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccountInfo>>,
  TError,
  { data: AccountInfoUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAccountInfo'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccountInfo>>,
    { data: AccountInfoUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccountInfo(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccountInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateAccountInfo>>>;
export type UpdateAccountInfoMutationBody = AccountInfoUpdateRequest;
export type UpdateAccountInfoMutationError = unknown;

/**
 * @summary 정산 계좌 정보 수정
 */
export const useUpdateAccountInfo = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAccountInfo>>,
      TError,
      { data: AccountInfoUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAccountInfo>>,
  TError,
  { data: AccountInfoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAccountInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 활성화된 배달원 프로필의 상세 정보를 조회합니다.
 * @summary 내 배달원 프로필 조회
 */
export const getMyProfile1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseRiderProfileResponse>({ url: `/api/v1/users/me/rider`, method: 'GET', signal });
};

export const getGetMyProfile1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/rider`] as const;
};

export const getGetMyProfile1QueryKey = () => {
  return [`/api/v1/users/me/rider`] as const;
};

export const getGetMyProfile1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile1>>> = ({ signal }) => getMyProfile1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyProfile1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile1>>>;
export type GetMyProfile1InfiniteQueryError = unknown;

export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 배달원 프로필 조회
 */

export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyProfile1QueryOptions = <
  TData = Awaited<ReturnType<typeof getMyProfile1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile1>>> = ({ signal }) => getMyProfile1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyProfile1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile1QueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile1>>>;
export type GetMyProfile1QueryError = unknown;

export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 배달원 프로필 조회
 */

export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 배달원 프로필의 닉네임, 프로필 이미지를 수정합니다.
 * @summary 내 배달원 프로필 수정
 */
export const updateMyProfile1 = (riderProfileUpdateRequest: RiderProfileUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderProfileUpdateRequest,
  });
};

export const getUpdateMyProfile1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyProfile1>>,
    TError,
    { data: RiderProfileUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMyProfile1>>,
  TError,
  { data: RiderProfileUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateMyProfile1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMyProfile1>>,
    { data: RiderProfileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMyProfile1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyProfile1MutationResult = NonNullable<Awaited<ReturnType<typeof updateMyProfile1>>>;
export type UpdateMyProfile1MutationBody = RiderProfileUpdateRequest;
export type UpdateMyProfile1MutationError = unknown;

/**
 * @summary 내 배달원 프로필 수정
 */
export const useUpdateMyProfile1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyProfile1>>,
      TError,
      { data: RiderProfileUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMyProfile1>>,
  TError,
  { data: RiderProfileUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateMyProfile1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 배달 상태를 ON 또는 OFF로 직접 설정합니다.
 * @summary 배달 상태 설정
 */
export const updateDeliveryStatus = (riderStatusUpdateRequest: RiderStatusUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/status`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderStatusUpdateRequest,
  });
};

export const getUpdateDeliveryStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeliveryStatus>>,
    TError,
    { data: RiderStatusUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeliveryStatus>>,
  TError,
  { data: RiderStatusUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateDeliveryStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeliveryStatus>>,
    { data: RiderStatusUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateDeliveryStatus(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeliveryStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateDeliveryStatus>>>;
export type UpdateDeliveryStatusMutationBody = RiderStatusUpdateRequest;
export type UpdateDeliveryStatusMutationError = unknown;

/**
 * @summary 배달 상태 설정
 */
export const useUpdateDeliveryStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeliveryStatus>>,
      TError,
      { data: RiderStatusUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeliveryStatus>>,
  TError,
  { data: RiderStatusUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateDeliveryStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 설정된 활동 지역을 조회합니다.
 * @summary 활동 지역 조회
 */
export const getDeliveryArea = (signal?: AbortSignal) => {
  return customInstance<ApiResponseString>({ url: `/api/v1/users/me/rider/area`, method: 'GET', signal });
};

export const getGetDeliveryAreaInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/rider/area`] as const;
};

export const getGetDeliveryAreaQueryKey = () => {
  return [`/api/v1/users/me/rider/area`] as const;
};

export const getGetDeliveryAreaInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDeliveryAreaInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeliveryArea>>> = ({ signal }) => getDeliveryArea(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDeliveryArea>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDeliveryAreaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDeliveryArea>>>;
export type GetDeliveryAreaInfiniteQueryError = unknown;

export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 활동 지역 조회
 */

export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDeliveryAreaInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDeliveryAreaQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeliveryArea>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDeliveryAreaQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeliveryArea>>> = ({ signal }) => getDeliveryArea(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeliveryArea>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDeliveryAreaQueryResult = NonNullable<Awaited<ReturnType<typeof getDeliveryArea>>>;
export type GetDeliveryAreaQueryError = unknown;

export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 활동 지역 조회
 */

export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDeliveryAreaQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 배달원의 활동 지역을 변경합니다.
 * @summary 활동 지역 수정
 */
export const updateDeliveryArea = (riderAreaUpdateRequest: RiderAreaUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/area`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderAreaUpdateRequest,
  });
};

export const getUpdateDeliveryAreaMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeliveryArea>>,
    TError,
    { data: RiderAreaUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeliveryArea>>,
  TError,
  { data: RiderAreaUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateDeliveryArea'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeliveryArea>>,
    { data: RiderAreaUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateDeliveryArea(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeliveryAreaMutationResult = NonNullable<Awaited<ReturnType<typeof updateDeliveryArea>>>;
export type UpdateDeliveryAreaMutationBody = RiderAreaUpdateRequest;
export type UpdateDeliveryAreaMutationError = unknown;

/**
 * @summary 활동 지역 수정
 */
export const useUpdateDeliveryArea = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeliveryArea>>,
      TError,
      { data: RiderAreaUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeliveryArea>>,
  TError,
  { data: RiderAreaUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateDeliveryAreaMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 은행명, 계좌번호, 예금주를 수정합니다.
 * @summary 정산 계좌 정보 수정
 */
export const updateAccountInfo1 = (riderAccountInfoUpdateRequest: RiderAccountInfoUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/account-info`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderAccountInfoUpdateRequest,
  });
};

export const getUpdateAccountInfo1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccountInfo1>>,
    TError,
    { data: RiderAccountInfoUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccountInfo1>>,
  TError,
  { data: RiderAccountInfoUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAccountInfo1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccountInfo1>>,
    { data: RiderAccountInfoUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccountInfo1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccountInfo1MutationResult = NonNullable<Awaited<ReturnType<typeof updateAccountInfo1>>>;
export type UpdateAccountInfo1MutationBody = RiderAccountInfoUpdateRequest;
export type UpdateAccountInfo1MutationError = unknown;

/**
 * @summary 정산 계좌 정보 수정
 */
export const useUpdateAccountInfo1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAccountInfo1>>,
      TError,
      { data: RiderAccountInfoUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAccountInfo1>>,
  TError,
  { data: RiderAccountInfoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAccountInfo1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 비밀번호를 확인하고 새로운 비밀번호로 변경합니다.
 * @summary 비밀번호 변경
 */
export const changePassword = (changePasswordRequest: ChangePasswordRequest) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/users/me/password`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: changePasswordRequest,
  });
};

export const getChangePasswordMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changePassword>>,
    TError,
    { data: ChangePasswordRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof changePassword>>,
  TError,
  { data: ChangePasswordRequest },
  TContext
> => {
  const mutationKey = ['changePassword'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePassword>>, { data: ChangePasswordRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return changePassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof changePassword>>>;
export type ChangePasswordMutationBody = ChangePasswordRequest;
export type ChangePasswordMutationError = unknown;

/**
 * @summary 비밀번호 변경
 */
export const useChangePassword = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changePassword>>,
      TError,
      { data: ChangePasswordRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof changePassword>>, TError, { data: ChangePasswordRequest }, TContext> => {
  const mutationOptions = getChangePasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 활성화된 고객 프로필의 상세 정보를 조회합니다.
 * @summary 내 고객 프로필 조회
 */
export const getMyProfile2 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseCustomerProfileResponse>({
    url: `/api/v1/users/me/customer`,
    method: 'GET',
    signal,
  });
};

export const getGetMyProfile2InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/customer`] as const;
};

export const getGetMyProfile2QueryKey = () => {
  return [`/api/v1/users/me/customer`] as const;
};

export const getGetMyProfile2InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile2InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile2>>> = ({ signal }) => getMyProfile2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyProfile2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile2InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile2>>>;
export type GetMyProfile2InfiniteQueryError = unknown;

export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 고객 프로필 조회
 */

export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile2InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyProfile2QueryOptions = <
  TData = Awaited<ReturnType<typeof getMyProfile2>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile2>>> = ({ signal }) => getMyProfile2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyProfile2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile2QueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile2>>>;
export type GetMyProfile2QueryError = unknown;

export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 고객 프로필 조회
 */

export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile2QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 고객 프로필의 닉네임, 프로필 이미지를 수정합니다.
 * @summary 내 고객 프로필 수정
 */
export const updateMyProfile2 = (customerProfileUpdateRequest: CustomerProfileUpdateRequest) => {
  return customInstance<ApiResponseCustomerProfileResponse>({
    url: `/api/v1/users/me/customer`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: customerProfileUpdateRequest,
  });
};

export const getUpdateMyProfile2MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyProfile2>>,
    TError,
    { data: CustomerProfileUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMyProfile2>>,
  TError,
  { data: CustomerProfileUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateMyProfile2'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMyProfile2>>,
    { data: CustomerProfileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMyProfile2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyProfile2MutationResult = NonNullable<Awaited<ReturnType<typeof updateMyProfile2>>>;
export type UpdateMyProfile2MutationBody = CustomerProfileUpdateRequest;
export type UpdateMyProfile2MutationError = unknown;

/**
 * @summary 내 고객 프로필 수정
 */
export const useUpdateMyProfile2 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyProfile2>>,
      TError,
      { data: CustomerProfileUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMyProfile2>>,
  TError,
  { data: CustomerProfileUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateMyProfile2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 배송지 ID로 특정 배송지의 상세 정보를 조회합니다.
 * @summary 특정 배송지 조회
 */
export const getAddress = (addressId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses/${addressId}`,
    method: 'GET',
    signal,
  });
};

export const getGetAddressInfiniteQueryKey = (addressId?: number) => {
  return ['infinate', `/api/v1/users/me/customer/addresses/${addressId}`] as const;
};

export const getGetAddressQueryKey = (addressId?: number) => {
  return [`/api/v1/users/me/customer/addresses/${addressId}`] as const;
};

export const getGetAddressInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>,
  TError = unknown,
>(
  addressId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAddressInfiniteQueryKey(addressId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAddress>>> = ({ signal }) => getAddress(addressId, signal);

  return { queryKey, queryFn, enabled: !!addressId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAddressInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAddress>>>;
export type GetAddressInfiniteQueryError = unknown;

export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 특정 배송지 조회
 */

export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAddressInfiniteQueryOptions(addressId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAddressQueryOptions = <TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAddressQueryKey(addressId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAddress>>> = ({ signal }) => getAddress(addressId, signal);

  return { queryKey, queryFn, enabled: !!addressId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getAddress>>>;
export type GetAddressQueryError = unknown;

export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 특정 배송지 조회
 */

export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAddressQueryOptions(addressId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 기존 배송지의 정보를 수정합니다.
 * @summary 배송지 수정
 */
export const updateAddress = (addressId: number, addressUpdateRequest: AddressUpdateRequest) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses/${addressId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: addressUpdateRequest,
  });
};

export const getUpdateAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAddress>>,
    TError,
    { addressId: number; data: AddressUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAddress>>,
  TError,
  { addressId: number; data: AddressUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAddress>>,
    { addressId: number; data: AddressUpdateRequest }
  > = (props) => {
    const { addressId, data } = props ?? {};

    return updateAddress(addressId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAddressMutationResult = NonNullable<Awaited<ReturnType<typeof updateAddress>>>;
export type UpdateAddressMutationBody = AddressUpdateRequest;
export type UpdateAddressMutationError = unknown;

/**
 * @summary 배송지 수정
 */
export const useUpdateAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAddress>>,
      TError,
      { addressId: number; data: AddressUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAddress>>,
  TError,
  { addressId: number; data: AddressUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 배송지를 삭제합니다. 기본 배송지는 삭제할 수 없습니다.
 * @summary 배송지 삭제
 */
export const deleteAddress = (addressId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/users/me/customer/addresses/${addressId}`, method: 'DELETE' });
};

export const getDeleteAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext> => {
  const mutationKey = ['deleteAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAddress>>, { addressId: number }> = (props) => {
    const { addressId } = props ?? {};

    return deleteAddress(addressId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAddressMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAddress>>>;

export type DeleteAddressMutationError = unknown;

/**
 * @summary 배송지 삭제
 */
export const useDeleteAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext> => {
  const mutationOptions = getDeleteAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 특정 배송지를 기본 배송지로 설정합니다.
 * @summary 기본 배송지 설정
 */
export const setDefaultAddress = (addressId: number) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/users/me/customer/addresses/${addressId}/default`,
    method: 'PUT',
  });
};

export const getSetDefaultAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof setDefaultAddress>>, TError, { addressId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof setDefaultAddress>>, TError, { addressId: number }, TContext> => {
  const mutationKey = ['setDefaultAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setDefaultAddress>>, { addressId: number }> = (
    props
  ) => {
    const { addressId } = props ?? {};

    return setDefaultAddress(addressId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetDefaultAddressMutationResult = NonNullable<Awaited<ReturnType<typeof setDefaultAddress>>>;

export type SetDefaultAddressMutationError = unknown;

/**
 * @summary 기본 배송지 설정
 */
export const useSetDefaultAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setDefaultAddress>>,
      TError,
      { addressId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof setDefaultAddress>>, TError, { addressId: number }, TContext> => {
  const mutationOptions = getSetDefaultAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 특정 상점의 정보를 조회합니다.
 * @summary 상점 단건 조회
 */
export const getStore = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseStoreResponse>({ url: `/api/v1/stores/${storeId}`, method: 'GET', signal });
};

export const getGetStoreInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}`] as const;
};

export const getGetStoreQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}`] as const;
};

export const getGetStoreInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStore>>> = ({ signal }) => getStore(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getStore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStore>>>;
export type GetStoreInfiniteQueryError = unknown;

export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상점 단건 조회
 */

export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetStoreQueryOptions = <TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStore>>> = ({ signal }) => getStore(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreQueryResult = NonNullable<Awaited<ReturnType<typeof getStore>>>;
export type GetStoreQueryError = unknown;

export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상점 단건 조회
 */

export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 특정 상점의 정보를 수정합니다, 본인의 상점 정보만 수정이 가능합니다.
 * @summary 상점 정보 수정
 */
export const updateStore = (storeId: number, storeUpdateRequest: StoreUpdateRequest) => {
  return customInstance<ApiResponseStoreResponse>({
    url: `/api/v1/stores/${storeId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: storeUpdateRequest,
  });
};

export const getUpdateStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStore>>,
    TError,
    { storeId: number; data: StoreUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStore>>,
  TError,
  { storeId: number; data: StoreUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStore>>,
    { storeId: number; data: StoreUpdateRequest }
  > = (props) => {
    const { storeId, data } = props ?? {};

    return updateStore(storeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStoreMutationResult = NonNullable<Awaited<ReturnType<typeof updateStore>>>;
export type UpdateStoreMutationBody = StoreUpdateRequest;
export type UpdateStoreMutationError = unknown;

/**
 * @summary 상점 정보 수정
 */
export const useUpdateStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateStore>>,
      TError,
      { storeId: number; data: StoreUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateStore>>,
  TError,
  { storeId: number; data: StoreUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 특정 상점을 삭제합니다, 본인의 상점만 삭제가 가능합니다.
 * @summary 상점 삭제
 */
export const deleteStore = (storeId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/stores/${storeId}`, method: 'DELETE' });
};

export const getDeleteStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext> => {
  const mutationKey = ['deleteStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStore>>, { storeId: number }> = (props) => {
    const { storeId } = props ?? {};

    return deleteStore(storeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteStoreMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStore>>>;

export type DeleteStoreMutationError = unknown;

/**
 * @summary 상점 삭제
 */
export const useDeleteStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext> => {
  const mutationOptions = getDeleteStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 특정 상품의 상세 정보를 조회합니다.
 * @summary 상품 상세 조회
 */
export const getProduct = (storeId: number, productId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseProductDetailResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}`,
    method: 'GET',
    signal,
  });
};

export const getGetProductInfiniteQueryKey = (storeId?: number, productId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/products/${productId}`] as const;
};

export const getGetProductQueryKey = (storeId?: number, productId?: number) => {
  return [`/api/v1/stores/${storeId}/products/${productId}`] as const;
};

export const getGetProductInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductInfiniteQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductInfiniteQueryError = unknown;

export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상품 상세 조회
 */

export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductInfiniteQueryOptions(storeId, productId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProductQueryOptions = <TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductQueryError = unknown;

export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상품 상세 조회
 */

export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductQueryOptions(storeId, productId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 특정 상품의 정보를 수정합니다.
 * @summary 상품 정보 수정
 */
export const updateProduct = (storeId: number, productId: number, productUpdateRequest: ProductUpdateRequest) => {
  return customInstance<ApiResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: productUpdateRequest,
  });
};

export const getUpdateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { storeId: number; productId: number; data: ProductUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { storeId: number; productId: number; data: ProductUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { storeId: number; productId: number; data: ProductUpdateRequest }
  > = (props) => {
    const { storeId, productId, data } = props ?? {};

    return updateProduct(storeId, productId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProductMutationResult = NonNullable<Awaited<ReturnType<typeof updateProduct>>>;
export type UpdateProductMutationBody = ProductUpdateRequest;
export type UpdateProductMutationError = unknown;

/**
 * @summary 상품 정보 수정
 */
export const useUpdateProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { storeId: number; productId: number; data: ProductUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { storeId: number; productId: number; data: ProductUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 특정 상품을 삭제합니다.
 * @summary 상품 삭제
 */
export const deleteProduct = (storeId: number, productId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/stores/${storeId}/products/${productId}`, method: 'DELETE' });
};

export const getDeleteProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { storeId: number; productId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { storeId: number; productId: number },
  TContext
> => {
  const mutationKey = ['deleteProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { storeId: number; productId: number }
  > = (props) => {
    const { storeId, productId } = props ?? {};

    return deleteProduct(storeId, productId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>;

export type DeleteProductMutationError = unknown;

/**
 * @summary 상품 삭제
 */
export const useDeleteProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { storeId: number; productId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { storeId: number; productId: number },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 클라이언트가 보낸 인증 코드를 검증하고, 성공 시 사용자 엔티티의 `isEmailVerified` 필드를 `true`로 업데이트합니다. **인증 대상 이메일은 로그인 정보로 서버에서 강제 주입**됩니다.
 * @summary 2. 로그인 사용자 이메일 인증 코드 검증
 */
export const verifyCode = (myEmailVerifyRequest: MyEmailVerifyRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/users/me/verify-email/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: myEmailVerifyRequest,
    signal,
  });
};

export const getVerifyCodeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyCode>>,
    TError,
    { data: MyEmailVerifyRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof verifyCode>>, TError, { data: MyEmailVerifyRequest }, TContext> => {
  const mutationKey = ['verifyCode'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCode>>, { data: MyEmailVerifyRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return verifyCode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyCodeMutationResult = NonNullable<Awaited<ReturnType<typeof verifyCode>>>;
export type VerifyCodeMutationBody = MyEmailVerifyRequest;
export type VerifyCodeMutationError = unknown;

/**
 * @summary 2. 로그인 사용자 이메일 인증 코드 검증
 */
export const useVerifyCode = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyCode>>,
      TError,
      { data: MyEmailVerifyRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof verifyCode>>, TError, { data: MyEmailVerifyRequest }, TContext> => {
  const mutationOptions = getVerifyCodeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 로그인된 사용자(`rq.getActor()`)의 이메일로 인증 코드를 발송합니다. **이메일 주소는 서버에서 강제 주입**되므로 클라이언트 요청 DTO가 필요 없습니다.
 * @summary 1. 로그인 사용자 이메일 인증 코드 발송
 */
export const sendVerificationCodeForMyEmail = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/users/me/verify-email/send`, method: 'POST', signal });
};

export const getSendVerificationCodeForMyEmailMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext> => {
  const mutationKey = ['sendVerificationCodeForMyEmail'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, void> = () => {
    return sendVerificationCodeForMyEmail();
  };

  return { mutationFn, ...mutationOptions };
};

export type SendVerificationCodeForMyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>
>;

export type SendVerificationCodeForMyEmailMutationError = unknown;

/**
 * @summary 1. 로그인 사용자 이메일 인증 코드 발송
 */
export const useSendVerificationCodeForMyEmail = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext> => {
  const mutationOptions = getSendVerificationCodeForMyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 배달 상태를 ON ↔ OFF로 전환합니다.
 * @summary 배달 상태 토글
 */
export const toggleDeliveryStatus = (signal?: AbortSignal) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/toggle`,
    method: 'POST',
    signal,
  });
};

export const getToggleDeliveryStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext> => {
  const mutationKey = ['toggleDeliveryStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleDeliveryStatus>>, void> = () => {
    return toggleDeliveryStatus();
  };

  return { mutationFn, ...mutationOptions };
};

export type ToggleDeliveryStatusMutationResult = NonNullable<Awaited<ReturnType<typeof toggleDeliveryStatus>>>;

export type ToggleDeliveryStatusMutationError = unknown;

/**
 * @summary 배달 상태 토글
 */
export const useToggleDeliveryStatus = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext> => {
  const mutationOptions = getToggleDeliveryStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 사용자가 보유한 모든 활성 프로필 목록과 현재 활성화된 프로필을 조회합니다.
 * @summary 사용 가능한 프로필 목록 조회
 */
export const getAvailableProfiles = (signal?: AbortSignal) => {
  return customInstance<ApiResponseAvailableProfilesResponse>({
    url: `/api/v1/users/me/profiles`,
    method: 'GET',
    signal,
  });
};

export const getGetAvailableProfilesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/profiles`] as const;
};

export const getGetAvailableProfilesQueryKey = () => {
  return [`/api/v1/users/me/profiles`] as const;
};

export const getGetAvailableProfilesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAvailableProfilesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableProfiles>>> = ({ signal }) =>
    getAvailableProfiles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAvailableProfiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAvailableProfilesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableProfiles>>>;
export type GetAvailableProfilesInfiniteQueryError = unknown;

export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 사용 가능한 프로필 목록 조회
 */

export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAvailableProfilesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAvailableProfilesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAvailableProfiles>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAvailableProfilesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableProfiles>>> = ({ signal }) =>
    getAvailableProfiles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAvailableProfiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAvailableProfilesQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableProfiles>>>;
export type GetAvailableProfilesQueryError = unknown;

export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 사용 가능한 프로필 목록 조회
 */

export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAvailableProfilesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 새로운 프로필을 생성합니다. 첫 번째 프로필이든 추가 프로필이든 동일하게 처리됩니다.
 * @summary 프로필 생성
 */
export const createProfile = (createProfileRequest: CreateProfileRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseCreateProfileResponse>({
    url: `/api/v1/users/me/profiles`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createProfileRequest,
    signal,
  });
};

export const getCreateProfileMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProfile>>,
    TError,
    { data: CreateProfileRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createProfile>>, TError, { data: CreateProfileRequest }, TContext> => {
  const mutationKey = ['createProfile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProfile>>, { data: CreateProfileRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProfileMutationResult = NonNullable<Awaited<ReturnType<typeof createProfile>>>;
export type CreateProfileMutationBody = CreateProfileRequest;
export type CreateProfileMutationError = unknown;

/**
 * @summary 프로필 생성
 */
export const useCreateProfile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProfile>>,
      TError,
      { data: CreateProfileRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createProfile>>, TError, { data: CreateProfileRequest }, TContext> => {
  const mutationOptions = getCreateProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 사용자가 보유한 다른 프로필로 전환합니다. 프로필 전환 시 새로운 Access Token이 자동으로 발급되며, 판매자 프로필인 경우 storeId와 프로필 상세 정보도 함께 반환됩니다.
 * @summary 프로필 전환
 */
export const switchProfile = (switchProfileRequest: SwitchProfileRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseSwitchProfileResponse>({
    url: `/api/v1/users/me/profile/switch`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: switchProfileRequest,
    signal,
  });
};

export const getSwitchProfileMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof switchProfile>>,
    TError,
    { data: SwitchProfileRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof switchProfile>>, TError, { data: SwitchProfileRequest }, TContext> => {
  const mutationKey = ['switchProfile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof switchProfile>>, { data: SwitchProfileRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return switchProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SwitchProfileMutationResult = NonNullable<Awaited<ReturnType<typeof switchProfile>>>;
export type SwitchProfileMutationBody = SwitchProfileRequest;
export type SwitchProfileMutationError = unknown;

/**
 * @summary 프로필 전환
 */
export const useSwitchProfile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof switchProfile>>,
      TError,
      { data: SwitchProfileRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof switchProfile>>, TError, { data: SwitchProfileRequest }, TContext> => {
  const mutationOptions = getSwitchProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 고객 프로필에 등록된 모든 배송지를 조회합니다.
 * @summary 내 배송지 목록 조회
 */
export const getMyAddresses = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListAddressResponse>({
    url: `/api/v1/users/me/customer/addresses`,
    method: 'GET',
    signal,
  });
};

export const getGetMyAddressesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/customer/addresses`] as const;
};

export const getGetMyAddressesQueryKey = () => {
  return [`/api/v1/users/me/customer/addresses`] as const;
};

export const getGetMyAddressesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyAddressesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyAddresses>>> = ({ signal }) => getMyAddresses(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyAddresses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyAddressesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyAddresses>>>;
export type GetMyAddressesInfiniteQueryError = unknown;

export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 배송지 목록 조회
 */

export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyAddressesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyAddressesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyAddresses>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyAddressesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyAddresses>>> = ({ signal }) => getMyAddresses(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyAddresses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyAddressesQueryResult = NonNullable<Awaited<ReturnType<typeof getMyAddresses>>>;
export type GetMyAddressesQueryError = unknown;

export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 배송지 목록 조회
 */

export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyAddressesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 새로운 배송지를 추가합니다. 첫 번째 배송지는 자동으로 기본 배송지로 설정됩니다.
 * @summary 배송지 추가
 */
export const addAddress = (addressCreateRequest: AddressCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: addressCreateRequest,
    signal,
  });
};

export const getAddAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addAddress>>,
    TError,
    { data: AddressCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof addAddress>>, TError, { data: AddressCreateRequest }, TContext> => {
  const mutationKey = ['addAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAddress>>, { data: AddressCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return addAddress(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddAddressMutationResult = NonNullable<Awaited<ReturnType<typeof addAddress>>>;
export type AddAddressMutationBody = AddressCreateRequest;
export type AddAddressMutationError = unknown;

/**
 * @summary 배송지 추가
 */
export const useAddAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addAddress>>,
      TError,
      { data: AddressCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof addAddress>>, TError, { data: AddressCreateRequest }, TContext> => {
  const mutationOptions = getAddAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 새로운 상점을 생성합니다, 상점은 하나의 SellerProfile 당 1개 생성 가능합니다.
 * @summary 상점 생성
 */
export const createStore = (storeCreateRequest: StoreCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseLong>({
    url: `/api/v1/stores`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: storeCreateRequest,
    signal,
  });
};

export const getCreateStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createStore>>,
    TError,
    { data: StoreCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createStore>>, TError, { data: StoreCreateRequest }, TContext> => {
  const mutationKey = ['createStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStore>>, { data: StoreCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createStore(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateStoreMutationResult = NonNullable<Awaited<ReturnType<typeof createStore>>>;
export type CreateStoreMutationBody = StoreCreateRequest;
export type CreateStoreMutationError = unknown;

/**
 * @summary 상점 생성
 */
export const useCreateStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createStore>>,
      TError,
      { data: StoreCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createStore>>, TError, { data: StoreCreateRequest }, TContext> => {
  const mutationOptions = getCreateStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 상점의 영업 상태(OPEN/CLOSED)를 변경합니다.
 * @summary 상점 영업상태 변경
 */
export const toggleStoreStatus = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseStoreResponse>({
    url: `/api/v1/stores/${storeId}/toggle-status`,
    method: 'POST',
    signal,
  });
};

export const getToggleStoreStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext> => {
  const mutationKey = ['toggleStoreStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleStoreStatus>>, { storeId: number }> = (props) => {
    const { storeId } = props ?? {};

    return toggleStoreStatus(storeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToggleStoreStatusMutationResult = NonNullable<Awaited<ReturnType<typeof toggleStoreStatus>>>;

export type ToggleStoreStatusMutationError = unknown;

/**
 * @summary 상점 영업상태 변경
 */
export const useToggleStoreStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext> => {
  const mutationOptions = getToggleStoreStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 특정 상점의 상품 목록을 조회합니다.
 * @summary 상품 목록 조회
 */
export const searchProducts = (storeId: number, params: SearchProductsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSearchProductsInfiniteQueryKey = (storeId?: number, params?: SearchProductsParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/products`, ...(params ? [params] : [])] as const;
};

export const getSearchProductsQueryKey = (storeId?: number, params?: SearchProductsParams) => {
  return [`/api/v1/stores/${storeId}/products`, ...(params ? [params] : [])] as const;
};

export const getSearchProductsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({ signal }) =>
    searchProducts(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchProductsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchProducts>>>;
export type SearchProductsInfiniteQueryError = unknown;

export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상품 목록 조회
 */

export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchProductsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchProductsQueryOptions = <TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({ signal }) =>
    searchProducts(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchProductsQueryResult = NonNullable<Awaited<ReturnType<typeof searchProducts>>>;
export type SearchProductsQueryError = unknown;

export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상품 목록 조회
 */

export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchProductsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 새로운 상품을 생성합니다.
 * @summary 상품 생성
 */
export const createProduct = (storeId: number, productCreateRequest: ProductCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: productCreateRequest,
    signal,
  });
};

export const getCreateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { storeId: number; data: ProductCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { storeId: number; data: ProductCreateRequest },
  TContext
> => {
  const mutationKey = ['createProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { storeId: number; data: ProductCreateRequest }
  > = (props) => {
    const { storeId, data } = props ?? {};

    return createProduct(storeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>;
export type CreateProductMutationBody = ProductCreateRequest;
export type CreateProductMutationError = unknown;

/**
 * @summary 상품 생성
 */
export const useCreateProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { storeId: number; data: ProductCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { storeId: number; data: ProductCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 새로운 리뷰를 생성합니다.
 * @summary 리뷰 생성
 */
export const createReview = (reviewCreateRequest: ReviewCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewCreateResponse>({
    url: `/api/v1/reviews`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: reviewCreateRequest,
    signal,
  });
};

export const getCreateReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createReview>>,
    TError,
    { data: ReviewCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError, { data: ReviewCreateRequest }, TContext> => {
  const mutationKey = ['createReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, { data: ReviewCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createReview(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>;
export type CreateReviewMutationBody = ReviewCreateRequest;
export type CreateReviewMutationError = unknown;

/**
 * @summary 리뷰 생성
 */
export const useCreateReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createReview>>,
      TError,
      { data: ReviewCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createReview>>, TError, { data: ReviewCreateRequest }, TContext> => {
  const mutationOptions = getCreateReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 로그인한 사용자가 특정 리뷰에 좋아요를 누릅니다. 이미 좋아요한 리뷰는 중복 등록할 수 없습니다.
 * @summary 리뷰 좋아요 등록
 */
export const likeReview = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewLikeResponse>({
    url: `/api/v1/reviews/${reviewId}/like`,
    method: 'POST',
    signal,
  });
};

export const getLikeReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['likeReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof likeReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return likeReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof likeReview>>>;

export type LikeReviewMutationError = unknown;

/**
 * @summary 리뷰 좋아요 등록
 */
export const useLikeReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getLikeReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 로그인한 사용자가 특정 리뷰에 좋아요를 누른 상태에서 다시 좋아요를 누르면 취소됩니다.
 * @summary 리뷰 좋아요 취소
 */
export const unLikeReview = (reviewId: number) => {
  return customInstance<ApiResponseReviewLikeResponse>({ url: `/api/v1/reviews/${reviewId}/like`, method: 'DELETE' });
};

export const getUnLikeReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['unLikeReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof unLikeReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return unLikeReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnLikeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof unLikeReview>>>;

export type UnLikeReviewMutationError = unknown;

/**
 * @summary 리뷰 좋아요 취소
 */
export const useUnLikeReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getUnLikeReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 특정 알림을 읽음으로 표시합니다.
 * @summary 알림 읽음 처리
 */
export const markAsRead = (id: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/notifications/${id}/read`, method: 'POST', signal });
};

export const getMarkAsReadMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext> => {
  const mutationKey = ['markAsRead'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof markAsRead>>, { id: number }> = (props) => {
    const { id } = props ?? {};

    return markAsRead(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkAsReadMutationResult = NonNullable<Awaited<ReturnType<typeof markAsRead>>>;

export type MarkAsReadMutationError = unknown;

/**
 * @summary 알림 읽음 처리
 */
export const useMarkAsRead = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext> => {
  const mutationOptions = getMarkAsReadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * S3에 파일을 업로드하기 위한 임시 URL(Pre-signed URL)을 생성합니다.
 * @summary 파일 업로드를 위한 Pre-signed URL 생성
 */
export const generatePresignedUrl = (
  generatePresignedUrlRequest: GeneratePresignedUrlRequest,
  signal?: AbortSignal
) => {
  return customInstance<ApiResponseGeneratePresignedUrlResponse>({
    url: `/api/v1/media/presigned-url`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: generatePresignedUrlRequest,
    signal,
  });
};

export const getGeneratePresignedUrlMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generatePresignedUrl>>,
    TError,
    { data: GeneratePresignedUrlRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generatePresignedUrl>>,
  TError,
  { data: GeneratePresignedUrlRequest },
  TContext
> => {
  const mutationKey = ['generatePresignedUrl'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generatePresignedUrl>>,
    { data: GeneratePresignedUrlRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generatePresignedUrl(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GeneratePresignedUrlMutationResult = NonNullable<Awaited<ReturnType<typeof generatePresignedUrl>>>;
export type GeneratePresignedUrlMutationBody = GeneratePresignedUrlRequest;
export type GeneratePresignedUrlMutationError = unknown;

/**
 * @summary 파일 업로드를 위한 Pre-signed URL 생성
 */
export const useGeneratePresignedUrl = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generatePresignedUrl>>,
      TError,
      { data: GeneratePresignedUrlRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof generatePresignedUrl>>,
  TError,
  { data: GeneratePresignedUrlRequest },
  TContext
> => {
  const mutationOptions = getGeneratePresignedUrlMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 라이더가 배달 요청에 대해 수락 또는 거절을 결정합니다.
 * @summary 라이더 배달 수락/거절 결정
 */
export const decideOrderDelivery = (riderDecisionRequestDto: RiderDecisionRequestDto, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/decision`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: riderDecisionRequestDto,
    signal,
  });
};

export const getDecideOrderDeliveryMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof decideOrderDelivery>>,
    TError,
    { data: RiderDecisionRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof decideOrderDelivery>>,
  TError,
  { data: RiderDecisionRequestDto },
  TContext
> => {
  const mutationKey = ['decideOrderDelivery'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof decideOrderDelivery>>,
    { data: RiderDecisionRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return decideOrderDelivery(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DecideOrderDeliveryMutationResult = NonNullable<Awaited<ReturnType<typeof decideOrderDelivery>>>;
export type DecideOrderDeliveryMutationBody = RiderDecisionRequestDto;
export type DecideOrderDeliveryMutationError = unknown;

/**
 * @summary 라이더 배달 수락/거절 결정
 */
export const useDecideOrderDelivery = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof decideOrderDelivery>>,
      TError,
      { data: RiderDecisionRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof decideOrderDelivery>>,
  TError,
  { data: RiderDecisionRequestDto },
  TContext
> => {
  const mutationOptions = getDecideOrderDeliveryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 배달 가능 지역을 설정합니다 (현재는 1군데만, 자유로운 형식으로 가능).
 * @summary 배달 가능 지역 설정
 */
export const updateDeliveryArea1 = (deliveryAreaRequestDto: DeliveryAreaRequestDto, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/area`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: deliveryAreaRequestDto,
    signal,
  });
};

export const getUpdateDeliveryArea1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeliveryArea1>>,
    TError,
    { data: DeliveryAreaRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeliveryArea1>>,
  TError,
  { data: DeliveryAreaRequestDto },
  TContext
> => {
  const mutationKey = ['updateDeliveryArea1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeliveryArea1>>,
    { data: DeliveryAreaRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateDeliveryArea1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeliveryArea1MutationResult = NonNullable<Awaited<ReturnType<typeof updateDeliveryArea1>>>;
export type UpdateDeliveryArea1MutationBody = DeliveryAreaRequestDto;
export type UpdateDeliveryArea1MutationError = unknown;

/**
 * @summary 배달 가능 지역 설정
 */
export const useUpdateDeliveryArea1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeliveryArea1>>,
      TError,
      { data: DeliveryAreaRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeliveryArea1>>,
  TError,
  { data: DeliveryAreaRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateDeliveryArea1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 소비자가 주문 내역을 요청한 경우
 * @summary 주문 내역 조회
 */
export const getAll = (params?: GetAllParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/customer/orders`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetAllInfiniteQueryKey = (params?: GetAllParams) => {
  return ['infinate', `/api/v1/customer/orders`, ...(params ? [params] : [])] as const;
};

export const getGetAllQueryKey = (params?: GetAllParams) => {
  return [`/api/v1/customer/orders`, ...(params ? [params] : [])] as const;
};

export const getGetAllInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
  TError = unknown,
>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllInfiniteQueryError = unknown;

export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params: undefined | GetAllParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 내역 조회
 */

export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllQueryOptions = <TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllQueryError = unknown;

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params: undefined | GetAllParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 내역 조회
 */

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 소비자가 상점에 주문을 요청한 경우
 * @summary 주문 생성
 */
export const create = (orderCreateRequest: OrderCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderCreateResponse>({
    url: `/api/v1/customer/orders`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderCreateRequest,
    signal,
  });
};

export const getCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext> => {
  const mutationKey = ['create'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof create>>, { data: OrderCreateRequest }> = (props) => {
    const { data } = props ?? {};

    return create(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMutationResult = NonNullable<Awaited<ReturnType<typeof create>>>;
export type CreateMutationBody = OrderCreateRequest;
export type CreateMutationError = unknown;

/**
 * @summary 주문 생성
 */
export const useCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext> => {
  const mutationOptions = getCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 소비자가 상점에서 주문 수락 전인 주문을 취소하는 경우
 * @summary 주문 취소
 */
export const cancel = (orderId: number, orderCancelRequest: OrderCancelRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/customer/orders/${orderId}/cancel`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderCancelRequest,
    signal,
  });
};

export const getCancelMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancel>>,
    TError,
    { orderId: number; data: OrderCancelRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancel>>,
  TError,
  { orderId: number; data: OrderCancelRequest },
  TContext
> => {
  const mutationKey = ['cancel'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancel>>,
    { orderId: number; data: OrderCancelRequest }
  > = (props) => {
    const { orderId, data } = props ?? {};

    return cancel(orderId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelMutationResult = NonNullable<Awaited<ReturnType<typeof cancel>>>;
export type CancelMutationBody = OrderCancelRequest;
export type CancelMutationError = unknown;

/**
 * @summary 주문 취소
 */
export const useCancel = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancel>>,
      TError,
      { orderId: number; data: OrderCancelRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancel>>,
  TError,
  { orderId: number; data: OrderCancelRequest },
  TContext
> => {
  const mutationOptions = getCancelMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 소비자가 생성한 주문의 결제 시도
 * @summary 주문 결제
 */
export const pay = (merchantUid: string, orderPayRequest: OrderPayRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/customer/orders/${merchantUid}/pay`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderPayRequest,
    signal,
  });
};

export const getPayMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pay>>,
    TError,
    { merchantUid: string; data: OrderPayRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pay>>,
  TError,
  { merchantUid: string; data: OrderPayRequest },
  TContext
> => {
  const mutationKey = ['pay'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pay>>,
    { merchantUid: string; data: OrderPayRequest }
  > = (props) => {
    const { merchantUid, data } = props ?? {};

    return pay(merchantUid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PayMutationResult = NonNullable<Awaited<ReturnType<typeof pay>>>;
export type PayMutationBody = OrderPayRequest;
export type PayMutationError = unknown;

/**
 * @summary 주문 결제
 */
export const usePay = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof pay>>,
      TError,
      { merchantUid: string; data: OrderPayRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof pay>>,
  TError,
  { merchantUid: string; data: OrderPayRequest },
  TContext
> => {
  const mutationOptions = getPayMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 사용자가 입력한 인증 코드를 검증합니다. 성공 시 해당 인증 정보는 Redis에서 삭제됩니다.
 * @summary 인증 코드 검증
 */
export const verifyCode1 = (verificationVerifyRequest: VerificationVerifyRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/verification/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: verificationVerifyRequest,
    signal,
  });
};

export const getVerifyCode1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyCode1>>,
    TError,
    { data: VerificationVerifyRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyCode1>>,
  TError,
  { data: VerificationVerifyRequest },
  TContext
> => {
  const mutationKey = ['verifyCode1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCode1>>, { data: VerificationVerifyRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return verifyCode1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyCode1MutationResult = NonNullable<Awaited<ReturnType<typeof verifyCode1>>>;
export type VerifyCode1MutationBody = VerificationVerifyRequest;
export type VerifyCode1MutationError = unknown;

/**
 * @summary 인증 코드 검증
 */
export const useVerifyCode1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyCode1>>,
      TError,
      { data: VerificationVerifyRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof verifyCode1>>,
  TError,
  { data: VerificationVerifyRequest },
  TContext
> => {
  const mutationOptions = getVerifyCode1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 이메일 또는 SMS로 인증 코드를 발송합니다. (현재는 이메일만 지원). 요청 시 `purpose`를 명시해야 합니다.
 * @summary 인증 코드 발송
 */
export const sendVerificationCode = (verificationSendRequest: VerificationSendRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/verification/send`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: verificationSendRequest,
    signal,
  });
};

export const getSendVerificationCodeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendVerificationCode>>,
    TError,
    { data: VerificationSendRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendVerificationCode>>,
  TError,
  { data: VerificationSendRequest },
  TContext
> => {
  const mutationKey = ['sendVerificationCode'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendVerificationCode>>,
    { data: VerificationSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return sendVerificationCode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendVerificationCodeMutationResult = NonNullable<Awaited<ReturnType<typeof sendVerificationCode>>>;
export type SendVerificationCodeMutationBody = VerificationSendRequest;
export type SendVerificationCodeMutationError = unknown;

/**
 * @summary 인증 코드 발송
 */
export const useSendVerificationCode = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendVerificationCode>>,
      TError,
      { data: VerificationSendRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sendVerificationCode>>,
  TError,
  { data: VerificationSendRequest },
  TContext
> => {
  const mutationOptions = getSendVerificationCodeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 이메일과 비밀번호로 신규 회원가입을 진행합니다. 비밀번호는 8자 이상, 영문/숫자/특수문자 포함이어야 합니다.
 * @summary 회원가입
 */
export const signup = (signupRequest: SignupRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseSignupResponse>({
    url: `/api/v1/auth/signup`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: signupRequest,
    signal,
  });
};

export const getSignupMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext> => {
  const mutationKey = ['signup'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signup>>, { data: SignupRequest }> = (props) => {
    const { data } = props ?? {};

    return signup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignupMutationResult = NonNullable<Awaited<ReturnType<typeof signup>>>;
export type SignupMutationBody = SignupRequest;
export type SignupMutationError = unknown;

/**
 * @summary 회원가입
 */
export const useSignup = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext> => {
  const mutationOptions = getSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * HttpOnly 쿠키에 저장된 Refresh Token을 사용하여 새로운 Access Token을 발급받습니다.
 * @summary 토큰 재발급
 */
export const refreshToken = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/auth/refresh`, method: 'POST', signal });
};

export const getRefreshTokenMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext> => {
  const mutationKey = ['refreshToken'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, void> = () => {
    return refreshToken();
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>;

export type RefreshTokenMutationError = unknown;

/**
 * @summary 토큰 재발급
 */
export const useRefreshToken = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext> => {
  const mutationOptions = getRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 인증 코드를 검증하고 비밀번호 재설정용 `resetToken`을 발급받습니다.
 * @summary 2단계: 인증 코드 검증 및 재설정 토큰 발급
 */
export const verifyCode2 = (passwordResetVerifyRequest: PasswordResetVerifyRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponsePasswordResetVerifyResponse>({
    url: `/api/v1/auth/password/reset/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: passwordResetVerifyRequest,
    signal,
  });
};

export const getVerifyCode2MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyCode2>>,
    TError,
    { data: PasswordResetVerifyRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyCode2>>,
  TError,
  { data: PasswordResetVerifyRequest },
  TContext
> => {
  const mutationKey = ['verifyCode2'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCode2>>, { data: PasswordResetVerifyRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return verifyCode2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyCode2MutationResult = NonNullable<Awaited<ReturnType<typeof verifyCode2>>>;
export type VerifyCode2MutationBody = PasswordResetVerifyRequest;
export type VerifyCode2MutationError = unknown;

/**
 * @summary 2단계: 인증 코드 검증 및 재설정 토큰 발급
 */
export const useVerifyCode2 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyCode2>>,
      TError,
      { data: PasswordResetVerifyRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof verifyCode2>>,
  TError,
  { data: PasswordResetVerifyRequest },
  TContext
> => {
  const mutationOptions = getVerifyCode2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 사용자 이메일로 비밀번호 재설정용 인증 코드를 발송합니다. (VerificationPurpose.PASSWORD_RESET 사용)
 * @summary 1단계: 비밀번호 재설정 요청 (인증 코드 발송)
 */
export const requestPasswordReset = (passwordResetRequest: PasswordResetRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/password/reset/request`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: passwordResetRequest,
    signal,
  });
};

export const getRequestPasswordResetMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    TError,
    { data: PasswordResetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: PasswordResetRequest },
  TContext
> => {
  const mutationKey = ['requestPasswordReset'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    { data: PasswordResetRequest }
  > = (props) => {
    const { data } = props ?? {};

    return requestPasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestPasswordResetMutationResult = NonNullable<Awaited<ReturnType<typeof requestPasswordReset>>>;
export type RequestPasswordResetMutationBody = PasswordResetRequest;
export type RequestPasswordResetMutationError = unknown;

/**
 * @summary 1단계: 비밀번호 재설정 요청 (인증 코드 발송)
 */
export const useRequestPasswordReset = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestPasswordReset>>,
      TError,
      { data: PasswordResetRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: PasswordResetRequest },
  TContext
> => {
  const mutationOptions = getRequestPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 발급받은 `resetToken`과 새 비밀번호를 사용하여 최종적으로 비밀번호를 변경합니다. 토큰은 사용 즉시 무효화됩니다.
 * @summary 3단계: 새 비밀번호 설정
 */
export const confirmPasswordReset = (
  passwordResetConfirmRequest: PasswordResetConfirmRequest,
  signal?: AbortSignal
) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/password/reset/confirm`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: passwordResetConfirmRequest,
    signal,
  });
};

export const getConfirmPasswordResetMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    TError,
    { data: PasswordResetConfirmRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: PasswordResetConfirmRequest },
  TContext
> => {
  const mutationKey = ['confirmPasswordReset'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    { data: PasswordResetConfirmRequest }
  > = (props) => {
    const { data } = props ?? {};

    return confirmPasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmPasswordResetMutationResult = NonNullable<Awaited<ReturnType<typeof confirmPasswordReset>>>;
export type ConfirmPasswordResetMutationBody = PasswordResetConfirmRequest;
export type ConfirmPasswordResetMutationError = unknown;

/**
 * @summary 3단계: 새 비밀번호 설정
 */
export const useConfirmPasswordReset = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmPasswordReset>>,
      TError,
      { data: PasswordResetConfirmRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: PasswordResetConfirmRequest },
  TContext
> => {
  const mutationOptions = getConfirmPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const logout = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/auth/logout`, method: 'POST', signal });
};

export const getLogoutMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationKey = ['logout'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
    return logout();
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError = unknown;

export const useLogout = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const logoutAll = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/auth/logout/all`, method: 'POST', signal });
};

export const getLogoutAllMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext> => {
  const mutationKey = ['logoutAll'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutAll>>, void> = () => {
    return logoutAll();
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutAllMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAll>>>;

export type LogoutAllMutationError = unknown;

export const useLogoutAll = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext> => {
  const mutationOptions = getLogoutAllMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 이메일과 비밀번호로 로그인합니다. Access Token과 Refresh Token이 발급됩니다. X-Device-ID 헤더가 없을 경우, 서버에서 생성하여 응답 헤더로 반환합니다.
 * @summary 로그인
 */
export const login = (loginRequest: LoginRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseLoginResponse>({
    url: `/api/v1/auth/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: loginRequest,
    signal,
  });
};

export const getLoginMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext> => {
  const mutationKey = ['login'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginRequest }> = (props) => {
    const { data } = props ?? {};

    return login(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = LoginRequest;
export type LoginMutationError = unknown;

/**
 * @summary 로그인
 */
export const useLogin = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 판매자가 상점의 주문을 거절한 경우
 * @summary 주문 거절
 */
export const rejectOrder = (storeId: number, orderId: number) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/stores/${storeId}/orders/${orderId}/reject`,
    method: 'PATCH',
  });
};

export const getRejectOrderMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectOrder>>,
    TError,
    { storeId: number; orderId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationKey = ['rejectOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectOrder>>, { storeId: number; orderId: number }> = (
    props
  ) => {
    const { storeId, orderId } = props ?? {};

    return rejectOrder(storeId, orderId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RejectOrderMutationResult = NonNullable<Awaited<ReturnType<typeof rejectOrder>>>;

export type RejectOrderMutationError = unknown;

/**
 * @summary 주문 거절
 */
export const useRejectOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectOrder>>,
      TError,
      { storeId: number; orderId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rejectOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationOptions = getRejectOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 판매자가 상점의 주문을 수락한 경우
 * @summary 주문 수락
 */
export const acceptOrder = (storeId: number, orderId: number) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/stores/${storeId}/orders/${orderId}/accept`,
    method: 'PATCH',
  });
};

export const getAcceptOrderMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptOrder>>,
    TError,
    { storeId: number; orderId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof acceptOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationKey = ['acceptOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof acceptOrder>>, { storeId: number; orderId: number }> = (
    props
  ) => {
    const { storeId, orderId } = props ?? {};

    return acceptOrder(storeId, orderId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AcceptOrderMutationResult = NonNullable<Awaited<ReturnType<typeof acceptOrder>>>;

export type AcceptOrderMutationError = unknown;

/**
 * @summary 주문 수락
 */
export const useAcceptOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof acceptOrder>>,
      TError,
      { storeId: number; orderId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof acceptOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationOptions = getAcceptOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 리뷰 id로 리뷰를 조회합니다.
 * @summary 리뷰 조회
 */
export const getReview = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewResponse>({ url: `/api/v1/reviews/${reviewId}`, method: 'GET', signal });
};

export const getGetReviewInfiniteQueryKey = (reviewId?: number) => {
  return ['infinate', `/api/v1/reviews/${reviewId}`] as const;
};

export const getGetReviewQueryKey = (reviewId?: number) => {
  return [`/api/v1/reviews/${reviewId}`] as const;
};

export const getGetReviewInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewInfiniteQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReview>>> = ({ signal }) => getReview(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReview>>>;
export type GetReviewInfiniteQueryError = unknown;

export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReview>>, TError, Awaited<ReturnType<typeof getReview>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReview>>,
          TError,
          Awaited<ReturnType<typeof getReview>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 리뷰 조회
 */

export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewInfiniteQueryOptions(reviewId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetReviewQueryOptions = <TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReview>>> = ({ signal }) => getReview(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewQueryResult = NonNullable<Awaited<ReturnType<typeof getReview>>>;
export type GetReviewQueryError = unknown;

export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReview>>, TError, Awaited<ReturnType<typeof getReview>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReview>>,
          TError,
          Awaited<ReturnType<typeof getReview>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 리뷰 조회
 */

export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewQueryOptions(reviewId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 리뷰를 삭제합니다.
 * @summary 리뷰 삭제
 */
export const deleteReview = (reviewId: number) => {
  return customInstance<ApiResponseString>({ url: `/api/v1/reviews/${reviewId}`, method: 'DELETE' });
};

export const getDeleteReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['deleteReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return deleteReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteReviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReview>>>;

export type DeleteReviewMutationError = unknown;

/**
 * @summary 리뷰 삭제
 */
export const useDeleteReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getDeleteReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 리뷰를 수정합니다.
 * @summary 리뷰 수정
 */
export const updateReview = (reviewId: number, reviewUpdateRequest: ReviewUpdateRequest) => {
  return customInstance<ApiResponseReviewResponse>({
    url: `/api/v1/reviews/${reviewId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: reviewUpdateRequest,
  });
};

export const getUpdateReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateReview>>,
    TError,
    { reviewId: number; data: ReviewUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateReview>>,
  TError,
  { reviewId: number; data: ReviewUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateReview>>,
    { reviewId: number; data: ReviewUpdateRequest }
  > = (props) => {
    const { reviewId, data } = props ?? {};

    return updateReview(reviewId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateReview>>>;
export type UpdateReviewMutationBody = ReviewUpdateRequest;
export type UpdateReviewMutationError = unknown;

/**
 * @summary 리뷰 수정
 */
export const useUpdateReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateReview>>,
      TError,
      { reviewId: number; data: ReviewUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateReview>>,
  TError,
  { reviewId: number; data: ReviewUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 배달 ID와 다음 상태를 받아 배달 상태를 변경합니다.
 * @summary 배달 상태 변경
 */
export const updateStatus = (deliveryId: number, params: UpdateStatusParams) => {
  return customInstance<void>({ url: `/api/v1/deliveries/${deliveryId}/delivery-status`, method: 'PATCH', params });
};

export const getUpdateStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStatus>>,
    TError,
    { deliveryId: number; params: UpdateStatusParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStatus>>,
  TError,
  { deliveryId: number; params: UpdateStatusParams },
  TContext
> => {
  const mutationKey = ['updateStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStatus>>,
    { deliveryId: number; params: UpdateStatusParams }
  > = (props) => {
    const { deliveryId, params } = props ?? {};

    return updateStatus(deliveryId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateStatus>>>;

export type UpdateStatusMutationError = unknown;

/**
 * @summary 배달 상태 변경
 */
export const useUpdateStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateStatus>>,
      TError,
      { deliveryId: number; params: UpdateStatusParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateStatus>>,
  TError,
  { deliveryId: number; params: UpdateStatusParams },
  TContext
> => {
  const mutationOptions = getUpdateStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 라이더 토글 전환으로 상태를 전환합니다.
 * @summary 라이더 토글 전환
 */
export const updateRiderStatus = (riderToggleStatusRequestDto: RiderToggleStatusRequestDto) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/status`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: riderToggleStatusRequestDto,
  });
};

export const getUpdateRiderStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRiderStatus>>,
    TError,
    { data: RiderToggleStatusRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRiderStatus>>,
  TError,
  { data: RiderToggleStatusRequestDto },
  TContext
> => {
  const mutationKey = ['updateRiderStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRiderStatus>>,
    { data: RiderToggleStatusRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateRiderStatus(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRiderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateRiderStatus>>>;
export type UpdateRiderStatusMutationBody = RiderToggleStatusRequestDto;
export type UpdateRiderStatusMutationError = unknown;

/**
 * @summary 라이더 토글 전환
 */
export const useUpdateRiderStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRiderStatus>>,
      TError,
      { data: RiderToggleStatusRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateRiderStatus>>,
  TError,
  { data: RiderToggleStatusRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateRiderStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * 현재 배달 가능한 상태인지 확인합니다. (프로필 활성화 + 배달 상태 ON)
 * @summary 배달 가능 여부 조회
 */
export const checkAvailability = (signal?: AbortSignal) => {
  return customInstance<ApiResponseBoolean>({ url: `/api/v1/users/me/rider/available`, method: 'GET', signal });
};

export const getCheckAvailabilityInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/rider/available`] as const;
};

export const getCheckAvailabilityQueryKey = () => {
  return [`/api/v1/users/me/rider/available`] as const;
};

export const getCheckAvailabilityInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckAvailabilityInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkAvailability>>> = ({ signal }) =>
    checkAvailability(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof checkAvailability>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CheckAvailabilityInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof checkAvailability>>>;
export type CheckAvailabilityInfiniteQueryError = unknown;

export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 배달 가능 여부 조회
 */

export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCheckAvailabilityInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCheckAvailabilityQueryOptions = <
  TData = Awaited<ReturnType<typeof checkAvailability>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckAvailabilityQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkAvailability>>> = ({ signal }) =>
    checkAvailability(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof checkAvailability>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CheckAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof checkAvailability>>>;
export type CheckAvailabilityQueryError = unknown;

export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 배달 가능 여부 조회
 */

export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCheckAvailabilityQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 현재 설정된 기본 배송지를 조회합니다.
 * @summary 기본 배송지 조회
 */
export const getDefaultAddress = (signal?: AbortSignal) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses/default`,
    method: 'GET',
    signal,
  });
};

export const getGetDefaultAddressInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/customer/addresses/default`] as const;
};

export const getGetDefaultAddressQueryKey = () => {
  return [`/api/v1/users/me/customer/addresses/default`] as const;
};

export const getGetDefaultAddressInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultAddressInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultAddress>>> = ({ signal }) =>
    getDefaultAddress(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDefaultAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDefaultAddressInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultAddress>>>;
export type GetDefaultAddressInfiniteQueryError = unknown;

export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 기본 배송지 조회
 */

export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDefaultAddressInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDefaultAddressQueryOptions = <
  TData = Awaited<ReturnType<typeof getDefaultAddress>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultAddressQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultAddress>>> = ({ signal }) =>
    getDefaultAddress(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDefaultAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDefaultAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultAddress>>>;
export type GetDefaultAddressQueryError = unknown;

export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 기본 배송지 조회
 */

export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDefaultAddressQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * sort, cursor, size 를 받아 특정 상점의 리뷰 리스트 및 평균 평점을 조회합니다.
 * @summary 특정 상점 리뷰 리스트 & 평점 조회
 */
export const getStoreReviews = (storeId: number, params: GetStoreReviewsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewRatingAndListResponseDto>({
    url: `/api/v1/stores/${storeId}/reviews`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetStoreReviewsInfiniteQueryKey = (storeId?: number, params?: GetStoreReviewsParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetStoreReviewsQueryKey = (storeId?: number, params?: GetStoreReviewsParams) => {
  return [`/api/v1/stores/${storeId}/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetStoreReviewsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreReviewsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreReviews>>> = ({ signal }) =>
    getStoreReviews(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getStoreReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreReviews>>>;
export type GetStoreReviewsInfiniteQueryError = unknown;

export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 특정 상점 리뷰 리스트 & 평점 조회
 */

export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreReviewsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetStoreReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreReviewsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreReviews>>> = ({ signal }) =>
    getStoreReviews(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStoreReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreReviews>>>;
export type GetStoreReviewsQueryError = unknown;

export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 특정 상점 리뷰 리스트 & 평점 조회
 */

export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreReviewsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 판매자가 상점의 주문 수락 대기 목록을 요청한 경우
 * @summary 주문 수락 대기 목록 조회
 */
export const getPendingOrders = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/pending`,
    method: 'GET',
    signal,
  });
};

export const getGetPendingOrdersInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/pending`] as const;
};

export const getGetPendingOrdersQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}/orders/pending`] as const;
};

export const getGetPendingOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingOrdersInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingOrders>>> = ({ signal }) =>
    getPendingOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPendingOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingOrders>>>;
export type GetPendingOrdersInfiniteQueryError = unknown;

export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 수락 대기 목록 조회
 */

export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPendingOrdersInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPendingOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingOrdersQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingOrders>>> = ({ signal }) =>
    getPendingOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPendingOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingOrders>>>;
export type GetPendingOrdersQueryError = unknown;

export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 수락 대기 목록 조회
 */

export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPendingOrdersQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 판매자가 주문 이력을 요청한 경우
 * @summary 주문 내역 조회
 */
export const getOrdersHistory = (storeId: number, params?: GetOrdersHistoryParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/history`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetOrdersHistoryInfiniteQueryKey = (storeId?: number, params?: GetOrdersHistoryParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/history`, ...(params ? [params] : [])] as const;
};

export const getGetOrdersHistoryQueryKey = (storeId?: number, params?: GetOrdersHistoryParams) => {
  return [`/api/v1/stores/${storeId}/orders/history`, ...(params ? [params] : [])] as const;
};

export const getGetOrdersHistoryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrdersHistoryInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersHistory>>> = ({ signal }) =>
    getOrdersHistory(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getOrdersHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrdersHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersHistory>>>;
export type GetOrdersHistoryInfiniteQueryError = unknown;

export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params: undefined | GetOrdersHistoryParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 내역 조회
 */

export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetOrdersHistoryInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetOrdersHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrdersHistoryQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersHistory>>> = ({ signal }) =>
    getOrdersHistory(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrdersHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrdersHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersHistory>>>;
export type GetOrdersHistoryQueryError = unknown;

export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params: undefined | GetOrdersHistoryParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 내역 조회
 */

export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetOrdersHistoryQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 판매자가 상점의 주문 처리 중인 목록을 요청한 경우
 * @summary 주문 현황 목록 조회
 */
export const getAcceptedOrders = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/accepted`,
    method: 'GET',
    signal,
  });
};

export const getGetAcceptedOrdersInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/accepted`] as const;
};

export const getGetAcceptedOrdersQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}/orders/accepted`] as const;
};

export const getGetAcceptedOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAcceptedOrdersInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcceptedOrders>>> = ({ signal }) =>
    getAcceptedOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAcceptedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAcceptedOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAcceptedOrders>>>;
export type GetAcceptedOrdersInfiniteQueryError = unknown;

export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 현황 목록 조회
 */

export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcceptedOrdersInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAcceptedOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAcceptedOrders>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAcceptedOrdersQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcceptedOrders>>> = ({ signal }) =>
    getAcceptedOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAcceptedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAcceptedOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getAcceptedOrders>>>;
export type GetAcceptedOrdersQueryError = unknown;

export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 현황 목록 조회
 */

export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcceptedOrdersQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 상점이 주간별 정산 내역을 요청한 경우
 * @summary 정산 주간별 조회
 */
export const getWeekSettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/week`,
    method: 'GET',
    signal,
  });
};

export const getGetWeekSettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/week`] as const;
};

export const getGetWeekSettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/week`] as const;
};

export const getGetWeekSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements>>> = ({ signal }) =>
    getWeekSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements>>>;
export type GetWeekSettlementsInfiniteQueryError = unknown;

export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 주간별 조회
 */

export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetWeekSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getWeekSettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements>>> = ({ signal }) =>
    getWeekSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements>>>;
export type GetWeekSettlementsQueryError = unknown;

export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 주간별 조회
 */

export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 상점이 특정 기간의 정산 정보를 요청한 경우
 * @summary 정산 기간 조회
 */
export const getPeriodSettlements = (storeId: number, params: GetPeriodSettlementsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/period`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetPeriodSettlementsInfiniteQueryKey = (storeId?: number, params?: GetPeriodSettlementsParams) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlementsQueryKey = (storeId?: number, params?: GetPeriodSettlementsParams) => {
  return [`/api/v1/store/settlements/${storeId}/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlementsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements>>> = ({ signal }) =>
    getPeriodSettlements(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements>>>;
export type GetPeriodSettlementsInfiniteQueryError = unknown;

export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 기간 조회
 */

export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlementsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPeriodSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPeriodSettlements>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlementsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements>>> = ({ signal }) =>
    getPeriodSettlements(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements>>>;
export type GetPeriodSettlementsQueryError = unknown;

export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 기간 조회
 */

export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlementsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 상점이 월별 정산 내역을 요청한 경우
 * @summary 정산 월별 조회
 */
export const getMonthSettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/month`,
    method: 'GET',
    signal,
  });
};

export const getGetMonthSettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/month`] as const;
};

export const getGetMonthSettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/month`] as const;
};

export const getGetMonthSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements>>> = ({ signal }) =>
    getMonthSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements>>>;
export type GetMonthSettlementsInfiniteQueryError = unknown;

export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 월별 조회
 */

export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMonthSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMonthSettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements>>> = ({ signal }) =>
    getMonthSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements>>>;
export type GetMonthSettlementsQueryError = unknown;

export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 월별 조회
 */

export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 상점이 일별 정산 내역을 요청한 경우
 * @summary 정산 일별 조회
 */
export const getDaySettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/day`,
    method: 'GET',
    signal,
  });
};

export const getGetDaySettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/day`] as const;
};

export const getGetDaySettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/day`] as const;
};

export const getGetDaySettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements>>> = ({ signal }) =>
    getDaySettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements>>>;
export type GetDaySettlementsInfiniteQueryError = unknown;

export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 일별 조회
 */

export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDaySettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDaySettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements>>> = ({ signal }) =>
    getDaySettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements>>>;
export type GetDaySettlementsQueryError = unknown;

export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 일별 조회
 */

export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 모든 상점 카테고리 목록을 조회합니다.
 * @summary 상점 카테고리 목록 조회
 */
export const getCategories = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListStoreCategoryResponse>({
    url: `/api/v1/store-categories`,
    method: 'GET',
    signal,
  });
};

export const getGetCategoriesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/store-categories`] as const;
};

export const getGetCategoriesQueryKey = () => {
  return [`/api/v1/store-categories`] as const;
};

export const getGetCategoriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesInfiniteQueryError = unknown;

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상점 카테고리 목록 조회
 */

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesQueryError = unknown;

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상점 카테고리 목록 조회
 */

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 상점 검색 결과를 커서 기반 페이지네이션으로 조회합니다.
 * @summary 상점 검색
 */
export const searchStores = (params: SearchStoresParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseStoreSearchResponse>({
    url: `/api/v1/search/stores`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSearchStoresInfiniteQueryKey = (params?: SearchStoresParams) => {
  return ['infinate', `/api/v1/search/stores`, ...(params ? [params] : [])] as const;
};

export const getSearchStoresQueryKey = (params?: SearchStoresParams) => {
  return [`/api/v1/search/stores`, ...(params ? [params] : [])] as const;
};

export const getSearchStoresInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStoresInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStores>>> = ({ signal }) => searchStores(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchStores>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchStoresInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchStores>>>;
export type SearchStoresInfiniteQueryError = unknown;

export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상점 검색
 */

export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchStoresInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchStoresQueryOptions = <TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStoresQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStores>>> = ({ signal }) => searchStores(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchStores>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchStoresQueryResult = NonNullable<Awaited<ReturnType<typeof searchStores>>>;
export type SearchStoresQueryError = unknown;

export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 상점 검색
 */

export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchStoresQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 배달원이 주간별 정산 내역을 요청한 경우
 * @summary 정산 주간별 조회
 */
export const getWeekSettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/week`,
    method: 'GET',
    signal,
  });
};

export const getGetWeekSettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/week`] as const;
};

export const getGetWeekSettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/week`] as const;
};

export const getGetWeekSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements1>>> = ({ signal }) =>
    getWeekSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements1>>>;
export type GetWeekSettlements1InfiniteQueryError = unknown;

export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 주간별 조회
 */

export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetWeekSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getWeekSettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements1>>> = ({ signal }) =>
    getWeekSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements1>>>;
export type GetWeekSettlements1QueryError = unknown;

export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 주간별 조회
 */

export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 배달원이 정산 요약 카드 정보를 요청한 경우
 * @summary 정산 요약 조회
 */
export const getSummary = (signal?: AbortSignal) => {
  return customInstance<ApiResponseSummaryResponse>({
    url: `/api/v1/rider/settlements/summary`,
    method: 'GET',
    signal,
  });
};

export const getGetSummaryInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/summary`] as const;
};

export const getGetSummaryQueryKey = () => {
  return [`/api/v1/rider/settlements/summary`] as const;
};

export const getGetSummaryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSummaryInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSummary>>> = ({ signal }) => getSummary(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSummaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSummary>>>;
export type GetSummaryInfiniteQueryError = unknown;

export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 요약 조회
 */

export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSummaryInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSummaryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSummary>>> = ({ signal }) => getSummary(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getSummary>>>;
export type GetSummaryQueryError = unknown;

export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 요약 조회
 */

export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSummaryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 배달원이 특정 기간의 정산 정보를 요청한 경우
 * @summary 정산 기간 조회
 */
export const getPeriodSettlements1 = (params: GetPeriodSettlements1Params, signal?: AbortSignal) => {
  return customInstance<ApiResponseSettlementResponse>({
    url: `/api/v1/rider/settlements/period`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetPeriodSettlements1InfiniteQueryKey = (params?: GetPeriodSettlements1Params) => {
  return ['infinate', `/api/v1/rider/settlements/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlements1QueryKey = (params?: GetPeriodSettlements1Params) => {
  return [`/api/v1/rider/settlements/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlements1InfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements1>>> = ({ signal }) =>
    getPeriodSettlements1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements1>>>;
export type GetPeriodSettlements1InfiniteQueryError = unknown;

export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 기간 조회
 */

export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlements1InfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPeriodSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getPeriodSettlements1>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlements1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements1>>> = ({ signal }) =>
    getPeriodSettlements1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements1>>>;
export type GetPeriodSettlements1QueryError = unknown;

export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 기간 조회
 */

export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlements1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 배달원이 월별 정산 내역을 요청한 경우
 * @summary 정산 월별 조회
 */
export const getMonthSettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/month`,
    method: 'GET',
    signal,
  });
};

export const getGetMonthSettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/month`] as const;
};

export const getGetMonthSettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/month`] as const;
};

export const getGetMonthSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements1>>> = ({ signal }) =>
    getMonthSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements1>>>;
export type GetMonthSettlements1InfiniteQueryError = unknown;

export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 월별 조회
 */

export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMonthSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getMonthSettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements1>>> = ({ signal }) =>
    getMonthSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements1>>>;
export type GetMonthSettlements1QueryError = unknown;

export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 월별 조회
 */

export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 배달원이 일별 정산 내역을 요청한 경우
 * @summary 정산 일별 조회
 */
export const getDaySettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/day`,
    method: 'GET',
    signal,
  });
};

export const getGetDaySettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/day`] as const;
};

export const getGetDaySettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/day`] as const;
};

export const getGetDaySettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements1>>> = ({ signal }) =>
    getDaySettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements1>>>;
export type GetDaySettlements1InfiniteQueryError = unknown;

export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 일별 조회
 */

export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDaySettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getDaySettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements1>>> = ({ signal }) =>
    getDaySettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements1>>>;
export type GetDaySettlements1QueryError = unknown;

export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 정산 일별 조회
 */

export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 라이더가 어떤 주문의 상세 정보를 요청한 경우
 * @summary 주문 단일 조회
 */
export const get = (orderId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({ url: `/api/v1/rider/orders/${orderId}`, method: 'GET', signal });
};

export const getGetInfiniteQueryKey = (orderId?: number) => {
  return ['infinate', `/api/v1/rider/orders/${orderId}`] as const;
};

export const getGetQueryKey = (orderId?: number) => {
  return [`/api/v1/rider/orders/${orderId}`] as const;
};

export const getGetInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInfiniteQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetInfiniteQueryError = unknown;

export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 단일 조회
 */

export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInfiniteQueryOptions(orderId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetQueryError = unknown;

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 단일 조회
 */

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetQueryOptions(orderId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 특정 리뷰에 달린 좋아요의 수를 조회합니다.
 * @summary 리뷰 좋아요 수 조회
 */
export const getReviewLikeCount = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewLikeResponse>({
    url: `/api/v1/reviews/${reviewId}/likes`,
    method: 'GET',
    signal,
  });
};

export const getGetReviewLikeCountInfiniteQueryKey = (reviewId?: number) => {
  return ['infinate', `/api/v1/reviews/${reviewId}/likes`] as const;
};

export const getGetReviewLikeCountQueryKey = (reviewId?: number) => {
  return [`/api/v1/reviews/${reviewId}/likes`] as const;
};

export const getGetReviewLikeCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewLikeCountInfiniteQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewLikeCount>>> = ({ signal }) =>
    getReviewLikeCount(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReviewLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewLikeCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewLikeCount>>>;
export type GetReviewLikeCountInfiniteQueryError = unknown;

export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 리뷰 좋아요 수 조회
 */

export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewLikeCountInfiniteQueryOptions(reviewId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetReviewLikeCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getReviewLikeCount>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewLikeCountQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewLikeCount>>> = ({ signal }) =>
    getReviewLikeCount(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReviewLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewLikeCountQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewLikeCount>>>;
export type GetReviewLikeCountQueryError = unknown;

export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 리뷰 좋아요 수 조회
 */

export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewLikeCountQueryOptions(reviewId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 사용자의 알림 목록을 조회합니다. isRead 파라미터로 읽음/안읽음 필터링이 가능합니다.
 * @summary 알림 목록 조회
 */
export const getNotifications = (params?: GetNotificationsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseListNotification>({ url: `/api/v1/notifications`, method: 'GET', params, signal });
};

export const getGetNotificationsInfiniteQueryKey = (params?: GetNotificationsParams) => {
  return ['infinate', `/api/v1/notifications`, ...(params ? [params] : [])] as const;
};

export const getGetNotificationsQueryKey = (params?: GetNotificationsParams) => {
  return [`/api/v1/notifications`, ...(params ? [params] : [])] as const;
};

export const getGetNotificationsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) =>
    getNotifications(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>;
export type GetNotificationsInfiniteQueryError = unknown;

export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params: undefined | GetNotificationsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 알림 목록 조회
 */

export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetNotificationsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) =>
    getNotifications(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>;
export type GetNotificationsQueryError = unknown;

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params: undefined | GetNotificationsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 알림 목록 조회
 */

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetNotificationsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 사용자의 읽지 않은 알림 수를 조회합니다.
 * @summary 읽지 않은 알림 수 조회
 */
export const getUnreadCount = (signal?: AbortSignal) => {
  return customInstance<ApiResponseLong>({ url: `/api/v1/notifications/unread-count`, method: 'GET', signal });
};

export const getGetUnreadCountInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/notifications/unread-count`] as const;
};

export const getGetUnreadCountQueryKey = () => {
  return [`/api/v1/notifications/unread-count`] as const;
};

export const getGetUnreadCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCount>>> = ({ signal }) => getUnreadCount(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCount>>>;
export type GetUnreadCountInfiniteQueryError = unknown;

export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 읽지 않은 알림 수 조회
 */

export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUnreadCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getUnreadCount>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCount>>> = ({ signal }) => getUnreadCount(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCount>>>;
export type GetUnreadCountQueryError = unknown;

export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 읽지 않은 알림 수 조회
 */

export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * SSE를 통해 실시간 알림을 구독합니다. 각 기기별로 고유한 deviceId를 헤더(X-Device-ID)에 담아 요청해야 합니다.
 * @summary SSE 구독
 */
export const subscribe = (signal?: AbortSignal) => {
  return customInstance<SseEmitter>({ url: `/api/v1/notifications/stream`, method: 'GET', signal });
};

export const getSubscribeInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/notifications/stream`] as const;
};

export const getSubscribeQueryKey = () => {
  return [`/api/v1/notifications/stream`] as const;
};

export const getSubscribeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSubscribeInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof subscribe>>> = ({ signal }) => subscribe(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof subscribe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SubscribeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof subscribe>>>;
export type SubscribeInfiniteQueryError = unknown;

export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof subscribe>>, TError, Awaited<ReturnType<typeof subscribe>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscribe>>,
          TError,
          Awaited<ReturnType<typeof subscribe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary SSE 구독
 */

export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSubscribeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSubscribeQueryOptions = <TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSubscribeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof subscribe>>> = ({ signal }) => subscribe(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof subscribe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SubscribeQueryResult = NonNullable<Awaited<ReturnType<typeof subscribe>>>;
export type SubscribeQueryError = unknown;

export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof subscribe>>, TError, Awaited<ReturnType<typeof subscribe>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscribe>>,
          TError,
          Awaited<ReturnType<typeof subscribe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary SSE 구독
 */

export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSubscribeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * sort, cursor, size와 사용자의 프로필에 따라 작성한 리뷰 or 내게 달린 리뷰 리스트 및 평균 평점을 조회합니다.
 * @summary 내 리뷰 리스트 & 평점 조회
 */
export const getMyReviews = (params: GetMyReviewsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewRatingAndListResponseDto>({
    url: `/api/v1/me/reviews`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetMyReviewsInfiniteQueryKey = (params?: GetMyReviewsParams) => {
  return ['infinate', `/api/v1/me/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetMyReviewsQueryKey = (params?: GetMyReviewsParams) => {
  return [`/api/v1/me/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetMyReviewsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyReviewsInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyReviews>>> = ({ signal }) => getMyReviews(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyReviews>>>;
export type GetMyReviewsInfiniteQueryError = unknown;

export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 리뷰 리스트 & 평점 조회
 */

export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyReviewsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyReviewsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyReviews>>> = ({ signal }) => getMyReviews(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyReviews>>>;
export type GetMyReviewsQueryError = unknown;

export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 내 리뷰 리스트 & 평점 조회
 */

export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyReviewsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 라이더의 총 배달 내역 요약과 배달 완료 리스트를 조회합니다. cursor 기반 페이징을 지원합니다. filter: LATEST(최신순), OLDEST(오래된순)
 * @summary 총 배달 내역 요약 조회 + 배달 완료 리스트 조회
 */
export const getTotalDeliveries = (params?: GetTotalDeliveriesParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseDeliveredSummaryResponseDto>({
    url: `/api/v1/deliveries/total`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetTotalDeliveriesInfiniteQueryKey = (params?: GetTotalDeliveriesParams) => {
  return ['infinate', `/api/v1/deliveries/total`, ...(params ? [params] : [])] as const;
};

export const getGetTotalDeliveriesQueryKey = (params?: GetTotalDeliveriesParams) => {
  return [`/api/v1/deliveries/total`, ...(params ? [params] : [])] as const;
};

export const getGetTotalDeliveriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalDeliveriesInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTotalDeliveries>>> = ({ signal }) =>
    getTotalDeliveries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTotalDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTotalDeliveries>>>;
export type GetTotalDeliveriesInfiniteQueryError = unknown;

export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params: undefined | GetTotalDeliveriesParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 총 배달 내역 요약 조회 + 배달 완료 리스트 조회
 */

export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTotalDeliveriesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTotalDeliveriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTotalDeliveries>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalDeliveriesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTotalDeliveries>>> = ({ signal }) =>
    getTotalDeliveries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTotalDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getTotalDeliveries>>>;
export type GetTotalDeliveriesQueryError = unknown;

export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params: undefined | GetTotalDeliveriesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 총 배달 내역 요약 조회 + 배달 완료 리스트 조회
 */

export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTotalDeliveriesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 라이더의 오늘 배달 내역을 조회합니다.
 * @summary 오늘의 배달 내역 조회
 */
export const getTodayDeliveries = (signal?: AbortSignal) => {
  return customInstance<ApiResponseTodayDeliveringResponseDto>({
    url: `/api/v1/deliveries/today`,
    method: 'GET',
    signal,
  });
};

export const getGetTodayDeliveriesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/deliveries/today`] as const;
};

export const getGetTodayDeliveriesQueryKey = () => {
  return [`/api/v1/deliveries/today`] as const;
};

export const getGetTodayDeliveriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTodayDeliveriesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodayDeliveries>>> = ({ signal }) =>
    getTodayDeliveries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTodayDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTodayDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTodayDeliveries>>>;
export type GetTodayDeliveriesInfiniteQueryError = unknown;

export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 오늘의 배달 내역 조회
 */

export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTodayDeliveriesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTodayDeliveriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTodayDeliveries>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTodayDeliveriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodayDeliveries>>> = ({ signal }) =>
    getTodayDeliveries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTodayDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTodayDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getTodayDeliveries>>>;
export type GetTodayDeliveriesQueryError = unknown;

export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 오늘의 배달 내역 조회
 */

export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTodayDeliveriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 라이더의 진행 중인 배달 내역을 조회합니다. (동적 riderProfile ID 필요성으로 인해 클라이언트 측에서 1분에 한 번씩 폴링 권장)
 * @summary 진행 중인 배달 조회
 */
export const getInProgressDelivery = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListCurrentDeliveringResponseDto>({
    url: `/api/v1/deliveries/in-progress`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressDeliveryInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/deliveries/in-progress`] as const;
};

export const getGetInProgressDeliveryQueryKey = () => {
  return [`/api/v1/deliveries/in-progress`] as const;
};

export const getGetInProgressDeliveryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDeliveryInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDelivery>>> = ({ signal }) =>
    getInProgressDelivery(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDeliveryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressDelivery>>>;
export type GetInProgressDeliveryInfiniteQueryError = unknown;

export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 진행 중인 배달 조회
 */

export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDeliveryInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressDeliveryQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressDelivery>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDeliveryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDelivery>>> = ({ signal }) =>
    getInProgressDelivery(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDeliveryQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressDelivery>>>;
export type GetInProgressDeliveryQueryError = unknown;

export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 진행 중인 배달 조회
 */

export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDeliveryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 라이더의 진행 중인 단일 배달 내역을 조회합니다. (동적 riderProfile ID 필요성으로 인해 클라이언트 측에서 1분에 한 번씩 폴링 권장)
 * @summary 진행 중인 배달 단건 상세 조회
 */
export const getInProgressDetailDelivery = (deliveryId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseCurrentDeliveringDetailsDto>({
    url: `/api/v1/deliveries/in-progress/${deliveryId}`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressDetailDeliveryInfiniteQueryKey = (deliveryId?: number) => {
  return ['infinate', `/api/v1/deliveries/in-progress/${deliveryId}`] as const;
};

export const getGetInProgressDetailDeliveryQueryKey = (deliveryId?: number) => {
  return [`/api/v1/deliveries/in-progress/${deliveryId}`] as const;
};

export const getGetInProgressDetailDeliveryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDetailDeliveryInfiniteQueryKey(deliveryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDetailDelivery>>> = ({ signal }) =>
    getInProgressDetailDelivery(deliveryId, signal);

  return { queryKey, queryFn, enabled: !!deliveryId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDetailDeliveryInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInProgressDetailDelivery>>
>;
export type GetInProgressDetailDeliveryInfiniteQueryError = unknown;

export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 진행 중인 배달 단건 상세 조회
 */

export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDetailDeliveryInfiniteQueryOptions(deliveryId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressDetailDeliveryQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDetailDeliveryQueryKey(deliveryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDetailDelivery>>> = ({ signal }) =>
    getInProgressDetailDelivery(deliveryId, signal);

  return { queryKey, queryFn, enabled: !!deliveryId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDetailDeliveryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInProgressDetailDelivery>>
>;
export type GetInProgressDetailDeliveryQueryError = unknown;

export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 진행 중인 배달 단건 상세 조회
 */

export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDetailDeliveryQueryOptions(deliveryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 소비자가 어떤 주문의 상세 정보를 요청한 경우
 * @summary 주문 단일 조회
 */
export const get1 = (orderId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({ url: `/api/v1/customer/orders/${orderId}`, method: 'GET', signal });
};

export const getGet1InfiniteQueryKey = (orderId?: number) => {
  return ['infinate', `/api/v1/customer/orders/${orderId}`] as const;
};

export const getGet1QueryKey = (orderId?: number) => {
  return [`/api/v1/customer/orders/${orderId}`] as const;
};

export const getGet1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGet1InfiniteQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get1>>> = ({ signal }) => get1(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof get1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Get1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof get1>>>;
export type Get1InfiniteQueryError = unknown;

export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 단일 조회
 */

export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGet1InfiniteQueryOptions(orderId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGet1QueryOptions = <TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGet1QueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get1>>> = ({ signal }) => get1(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Get1QueryResult = NonNullable<Awaited<ReturnType<typeof get1>>>;
export type Get1QueryError = unknown;

export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 주문 단일 조회
 */

export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGet1QueryOptions(orderId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 소비자가 진행중인 주문 내역을 요청한 경우
 * @summary 진행중인 주문 조회
 */
export const getInProgressOrders = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/customer/orders/in-progress`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressOrdersInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/customer/orders/in-progress`] as const;
};

export const getGetInProgressOrdersQueryKey = () => {
  return [`/api/v1/customer/orders/in-progress`] as const;
};

export const getGetInProgressOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressOrdersInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressOrders>>> = ({ signal }) =>
    getInProgressOrders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressOrders>>>;
export type GetInProgressOrdersInfiniteQueryError = unknown;

export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 진행중인 주문 조회
 */

export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressOrdersInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressOrders>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressOrdersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressOrders>>> = ({ signal }) =>
    getInProgressOrders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressOrders>>>;
export type GetInProgressOrdersQueryError = unknown;

export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 진행중인 주문 조회
 */

export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressOrdersQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 소비자가 배달 완료된 주문 내역을 요청한 경우
 * @summary 배달 완료된 주문 조회
 */
export const getCompletedOrders = (params?: GetCompletedOrdersParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/customer/orders/completed`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetCompletedOrdersInfiniteQueryKey = (params?: GetCompletedOrdersParams) => {
  return ['infinate', `/api/v1/customer/orders/completed`, ...(params ? [params] : [])] as const;
};

export const getGetCompletedOrdersQueryKey = (params?: GetCompletedOrdersParams) => {
  return [`/api/v1/customer/orders/completed`, ...(params ? [params] : [])] as const;
};

export const getGetCompletedOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCompletedOrdersInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompletedOrders>>> = ({ signal }) =>
    getCompletedOrders(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCompletedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCompletedOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCompletedOrders>>>;
export type GetCompletedOrdersInfiniteQueryError = unknown;

export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params: undefined | GetCompletedOrdersParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 배달 완료된 주문 조회
 */

export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCompletedOrdersInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCompletedOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof getCompletedOrders>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCompletedOrdersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompletedOrders>>> = ({ signal }) =>
    getCompletedOrders(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCompletedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCompletedOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getCompletedOrders>>>;
export type GetCompletedOrdersQueryError = unknown;

export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params: undefined | GetCompletedOrdersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params?: GetCompletedOrdersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary 배달 완료된 주문 조회
 */

export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCompletedOrdersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
