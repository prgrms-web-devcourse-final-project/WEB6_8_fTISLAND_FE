/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Î≠êÎì†Î∞∞Îã¨ API Î™ÖÏÑ∏ÏÑú
 * Î≠êÎì†Î∞∞Îã¨ API Î™ÖÏÑ∏ÏÑúÏûÖÎãàÎã§
 * OpenAPI spec version: v1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  ApiResponseCurrentDeliveringDetailsDto,
  ApiResponseCursorPageResponseOrderResponse,
  ApiResponseCursorPageResponseProductResponse,
  ApiResponseCursorPageResponseReviewResponse,
  ApiResponseCursorPageResponseStoreSearchResponse,
  ApiResponseDeliveredSummaryResponseDto,
  ApiResponseGeneratePresignedUrlResponse,
  ApiResponseListCurrentDeliveringResponseDto,
  ApiResponseListNotification,
  ApiResponseListOrderResponse,
  ApiResponseListSettlementResponse,
  ApiResponseListStoreCategoryResponse,
  ApiResponseLoginResponse,
  ApiResponseLong,
  ApiResponseOrderResponse,
  ApiResponseProductDetailResponse,
  ApiResponseProductResponse,
  ApiResponseReviewCreateResponse,
  ApiResponseReviewLikeResponse,
  ApiResponseReviewResponse,
  ApiResponseSettlementResponse,
  ApiResponseSignupResponse,
  ApiResponseStockResponse,
  ApiResponseStoreResponse,
  ApiResponseString,
  ApiResponseSummaryResponse,
  ApiResponseTodayDeliveringResponseDto,
  ApiResponseVoid,
  DeliveryAreaRequestDto,
  GeneratePresignedUrlRequest,
  GetAllParams,
  GetNotificationsParams,
  GetOrdersHistoryParams,
  GetPeriodSettlements1Params,
  GetPeriodSettlementsParams,
  GetStoreReviewsParams,
  GetTotalDeliveriesParams,
  GetUnreadCountParams,
  LoginRequest,
  MarkAsReadParams,
  OrderCancelRequest,
  OrderCreateRequest,
  OrderPayRequest,
  ProductCreateRequest,
  ProductUpdateRequest,
  ReviewCreateRequest,
  ReviewUpdateRequest,
  RiderDecisionRequestDto,
  RiderToggleStatusRequestDto,
  SearchProductsParams,
  SearchStoresParams,
  SignupRequest,
  SseEmitter,
  StockUpdateRequest,
  StoreCreateRequest,
  StoreUpdateRequest,
  SubscribeParams,
  UpdateStatusParams,
} from './model';

import { customInstance } from '../orval-mutator';
/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùò Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê Îã®Í±¥ Ï°∞Ìöå
 */
export const getStore = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseStoreResponse>({ url: `/api/v1/stores/${storeId}`, method: 'GET', signal });
};

export const getGetStoreInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}`] as const;
};

export const getGetStoreQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}`] as const;
};

export const getGetStoreInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStore>>> = ({ signal }) => getStore(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getStore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStore>>>;
export type GetStoreInfiniteQueryError = unknown;

export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetStoreQueryOptions = <TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStore>>> = ({ signal }) => getStore(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreQueryResult = NonNullable<Awaited<ReturnType<typeof getStore>>>;
export type GetStoreQueryError = unknown;

export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§, Î≥∏Ïù∏Ïùò ÏÉÅÏ†ê Ï†ïÎ≥¥Îßå ÏàòÏ†ïÏù¥ Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateStore = (storeId: number, storeUpdateRequest: StoreUpdateRequest) => {
  return customInstance<ApiResponseStoreResponse>({
    url: `/api/v1/stores/${storeId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: storeUpdateRequest,
  });
};

export const getUpdateStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStore>>,
    TError,
    { storeId: number; data: StoreUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStore>>,
  TError,
  { storeId: number; data: StoreUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStore>>,
    { storeId: number; data: StoreUpdateRequest }
  > = (props) => {
    const { storeId, data } = props ?? {};

    return updateStore(storeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStoreMutationResult = NonNullable<Awaited<ReturnType<typeof updateStore>>>;
export type UpdateStoreMutationBody = StoreUpdateRequest;
export type UpdateStoreMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateStore>>,
      TError,
      { storeId: number; data: StoreUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateStore>>,
  TError,
  { storeId: number; data: StoreUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§, Î≥∏Ïù∏Ïùò ÏÉÅÏ†êÎßå ÏÇ≠Ï†úÍ∞Ä Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê ÏÇ≠Ï†ú
 */
export const deleteStore = (storeId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/stores/${storeId}`, method: 'DELETE' });
};

export const getDeleteStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext> => {
  const mutationKey = ['deleteStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStore>>, { storeId: number }> = (props) => {
    const { storeId } = props ?? {};

    return deleteStore(storeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteStoreMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStore>>>;

export type DeleteStoreMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê ÏÇ≠Ï†ú
 */
export const useDeleteStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext> => {
  const mutationOptions = getDeleteStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getProduct = (storeId: number, productId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseProductDetailResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}`,
    method: 'GET',
    signal,
  });
};

export const getGetProductInfiniteQueryKey = (storeId?: number, productId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/products/${productId}`] as const;
};

export const getGetProductQueryKey = (storeId?: number, productId?: number) => {
  return [`/api/v1/stores/${storeId}/products/${productId}`] as const;
};

export const getGetProductInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductInfiniteQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductInfiniteQueryError = unknown;

export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductInfiniteQueryOptions(storeId, productId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProductQueryOptions = <TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductQueryError = unknown;

export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductQueryOptions(storeId, productId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateProduct = (storeId: number, productId: number, productUpdateRequest: ProductUpdateRequest) => {
  return customInstance<ApiResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: productUpdateRequest,
  });
};

export const getUpdateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { storeId: number; productId: number; data: ProductUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { storeId: number; productId: number; data: ProductUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { storeId: number; productId: number; data: ProductUpdateRequest }
  > = (props) => {
    const { storeId, productId, data } = props ?? {};

    return updateProduct(storeId, productId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProductMutationResult = NonNullable<Awaited<ReturnType<typeof updateProduct>>>;
export type UpdateProductMutationBody = ProductUpdateRequest;
export type UpdateProductMutationError = unknown;

/**
 * @summary ÏÉÅÌíà Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { storeId: number; productId: number; data: ProductUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { storeId: number; productId: number; data: ProductUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà ÏÇ≠Ï†ú
 */
export const deleteProduct = (storeId: number, productId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/stores/${storeId}/products/${productId}`, method: 'DELETE' });
};

export const getDeleteProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { storeId: number; productId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { storeId: number; productId: number },
  TContext
> => {
  const mutationKey = ['deleteProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { storeId: number; productId: number }
  > = (props) => {
    const { storeId, productId } = props ?? {};

    return deleteProduct(storeId, productId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>;

export type DeleteProductMutationError = unknown;

/**
 * @summary ÏÉÅÌíà ÏÇ≠Ï†ú
 */
export const useDeleteProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { storeId: number; productId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { storeId: number; productId: number },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùò Ïû¨Í≥† Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà Ïû¨Í≥† Ï°∞Ìöå
 */
export const getProductStock = (storeId: number, productId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseStockResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}/stock`,
    method: 'GET',
    signal,
  });
};

export const getGetProductStockInfiniteQueryKey = (storeId?: number, productId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/products/${productId}/stock`] as const;
};

export const getGetProductStockQueryKey = (storeId?: number, productId?: number) => {
  return [`/api/v1/stores/${storeId}/products/${productId}/stock`] as const;
};

export const getGetProductStockInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getProductStock>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductStockInfiniteQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductStock>>> = ({ signal }) =>
    getProductStock(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getProductStock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductStockInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProductStock>>>;
export type GetProductStockInfiniteQueryError = unknown;

export function useGetProductStockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProductStock>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductStock>>,
          TError,
          Awaited<ReturnType<typeof getProductStock>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductStockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProductStock>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductStock>>,
          TError,
          Awaited<ReturnType<typeof getProductStock>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductStockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProductStock>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà Ïû¨Í≥† Ï°∞Ìöå
 */

export function useGetProductStockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProductStock>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductStockInfiniteQueryOptions(storeId, productId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProductStockQueryOptions = <TData = Awaited<ReturnType<typeof getProductStock>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductStockQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductStock>>> = ({ signal }) =>
    getProductStock(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductStock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductStockQueryResult = NonNullable<Awaited<ReturnType<typeof getProductStock>>>;
export type GetProductStockQueryError = unknown;

export function useGetProductStock<TData = Awaited<ReturnType<typeof getProductStock>>, TError = unknown>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductStock>>,
          TError,
          Awaited<ReturnType<typeof getProductStock>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductStock<TData = Awaited<ReturnType<typeof getProductStock>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductStock>>,
          TError,
          Awaited<ReturnType<typeof getProductStock>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductStock<TData = Awaited<ReturnType<typeof getProductStock>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà Ïû¨Í≥† Ï°∞Ìöå
 */

export function useGetProductStock<TData = Awaited<ReturnType<typeof getProductStock>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductStock>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductStockQueryOptions(storeId, productId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùò Ïû¨Í≥†Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà Ïû¨Í≥† ÏàòÏ†ï
 */
export const updateProductStock = (storeId: number, productId: number, stockUpdateRequest: StockUpdateRequest) => {
  return customInstance<ApiResponseStockResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}/stock`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: stockUpdateRequest,
  });
};

export const getUpdateProductStockMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProductStock>>,
    TError,
    { storeId: number; productId: number; data: StockUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProductStock>>,
  TError,
  { storeId: number; productId: number; data: StockUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateProductStock'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProductStock>>,
    { storeId: number; productId: number; data: StockUpdateRequest }
  > = (props) => {
    const { storeId, productId, data } = props ?? {};

    return updateProductStock(storeId, productId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProductStockMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductStock>>>;
export type UpdateProductStockMutationBody = StockUpdateRequest;
export type UpdateProductStockMutationError = unknown;

/**
 * @summary ÏÉÅÌíà Ïû¨Í≥† ÏàòÏ†ï
 */
export const useUpdateProductStock = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProductStock>>,
      TError,
      { storeId: number; productId: number; data: StockUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProductStock>>,
  TError,
  { storeId: number; productId: number; data: StockUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateProductStockMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÉàÎ°úÏö¥ ÏÉÅÏ†êÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§, ÏÉÅÏ†êÏùÄ ÌïòÎÇòÏùò SellerProfile Îãπ 1Í∞ú ÏÉùÏÑ± Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê ÏÉùÏÑ±
 */
export const createStore = (storeCreateRequest: StoreCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseLong>({
    url: `/api/v1/stores`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: storeCreateRequest,
    signal,
  });
};

export const getCreateStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createStore>>,
    TError,
    { data: StoreCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createStore>>, TError, { data: StoreCreateRequest }, TContext> => {
  const mutationKey = ['createStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStore>>, { data: StoreCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createStore(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateStoreMutationResult = NonNullable<Awaited<ReturnType<typeof createStore>>>;
export type CreateStoreMutationBody = StoreCreateRequest;
export type CreateStoreMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê ÏÉùÏÑ±
 */
export const useCreateStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createStore>>,
      TError,
      { data: StoreCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createStore>>, TError, { data: StoreCreateRequest }, TContext> => {
  const mutationOptions = getCreateStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÉÅÏ†êÏùò ÏòÅÏóÖ ÏÉÅÌÉú(OPEN/CLOSED)Î•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê ÏòÅÏóÖÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const toggleStoreStatus = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseStoreResponse>({
    url: `/api/v1/stores/${storeId}/toggle-status`,
    method: 'POST',
    signal,
  });
};

export const getToggleStoreStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext> => {
  const mutationKey = ['toggleStoreStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleStoreStatus>>, { storeId: number }> = (props) => {
    const { storeId } = props ?? {};

    return toggleStoreStatus(storeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToggleStoreStatusMutationResult = NonNullable<Awaited<ReturnType<typeof toggleStoreStatus>>>;

export type ToggleStoreStatusMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê ÏòÅÏóÖÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useToggleStoreStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext> => {
  const mutationOptions = getToggleStoreStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùò ÏÉÅÌíà Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà Î™©Î°ù Ï°∞Ìöå
 */
export const searchProducts = (storeId: number, params: SearchProductsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSearchProductsInfiniteQueryKey = (storeId?: number, params?: SearchProductsParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/products`, ...(params ? [params] : [])] as const;
};

export const getSearchProductsQueryKey = (storeId?: number, params?: SearchProductsParams) => {
  return [`/api/v1/stores/${storeId}/products`, ...(params ? [params] : [])] as const;
};

export const getSearchProductsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({ signal }) =>
    searchProducts(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchProductsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchProducts>>>;
export type SearchProductsInfiniteQueryError = unknown;

export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà Î™©Î°ù Ï°∞Ìöå
 */

export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchProductsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchProductsQueryOptions = <TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({ signal }) =>
    searchProducts(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchProductsQueryResult = NonNullable<Awaited<ReturnType<typeof searchProducts>>>;
export type SearchProductsQueryError = unknown;

export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà Î™©Î°ù Ï°∞Ìöå
 */

export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchProductsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉàÎ°úÏö¥ ÏÉÅÌíàÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary ÏÉÅÌíà ÏÉùÏÑ±
 */
export const createProduct = (storeId: number, productCreateRequest: ProductCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: productCreateRequest,
    signal,
  });
};

export const getCreateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { storeId: number; data: ProductCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { storeId: number; data: ProductCreateRequest },
  TContext
> => {
  const mutationKey = ['createProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { storeId: number; data: ProductCreateRequest }
  > = (props) => {
    const { storeId, data } = props ?? {};

    return createProduct(storeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>;
export type CreateProductMutationBody = ProductCreateRequest;
export type CreateProductMutationError = unknown;

/**
 * @summary ÏÉÅÌíà ÏÉùÏÑ±
 */
export const useCreateProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { storeId: number; data: ProductCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { storeId: number; data: ProductCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÉàÎ°úÏö¥ Î¶¨Î∑∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ ÏÉùÏÑ±
 */
export const createReview = (reviewCreateRequest: ReviewCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewCreateResponse>({
    url: `/api/v1/reviews`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: reviewCreateRequest,
    signal,
  });
};

export const getCreateReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createReview>>,
    TError,
    { data: ReviewCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError, { data: ReviewCreateRequest }, TContext> => {
  const mutationKey = ['createReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, { data: ReviewCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createReview(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>;
export type CreateReviewMutationBody = ReviewCreateRequest;
export type CreateReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ ÏÉùÏÑ±
 */
export const useCreateReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createReview>>,
      TError,
      { data: ReviewCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createReview>>, TError, { data: ReviewCreateRequest }, TContext> => {
  const mutationOptions = getCreateReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÍ∞Ä ÌäπÏ†ï Î¶¨Î∑∞Ïóê Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ¶ÖÎãàÎã§. Ïù¥ÎØ∏ Ï¢ãÏïÑÏöîÌïú Î¶¨Î∑∞Îäî Ï§ëÎ≥µ Îì±Î°ùÌï† Ïàò ÏóÜÏäµÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const likeReview = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewLikeResponse>({
    url: `/api/v1/reviews/${reviewId}/like`,
    method: 'POST',
    signal,
  });
};

export const getLikeReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['likeReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof likeReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return likeReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof likeReview>>>;

export type LikeReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const useLikeReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getLikeReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÍ∞Ä ÌäπÏ†ï Î¶¨Î∑∞Ïóê Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ•∏ ÏÉÅÌÉúÏóêÏÑú Îã§Ïãú Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ•¥Î©¥ Ï∑®ÏÜåÎê©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const unLikeReview = (reviewId: number) => {
  return customInstance<ApiResponseReviewLikeResponse>({ url: `/api/v1/reviews/${reviewId}/like`, method: 'DELETE' });
};

export const getUnLikeReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['unLikeReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof unLikeReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return unLikeReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnLikeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof unLikeReview>>>;

export type UnLikeReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const useUnLikeReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getUnLikeReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏïåÎ¶ºÏùÑ ÏùΩÏùåÏúºÎ°ú ÌëúÏãúÌï©ÎãàÎã§.
 * @summary ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨
 */
export const markAsRead = (id: number, params: MarkAsReadParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/notifications/${id}/read`, method: 'POST', params, signal });
};

export const getMarkAsReadMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markAsRead>>,
    TError,
    { id: number; params: MarkAsReadParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markAsRead>>,
  TError,
  { id: number; params: MarkAsReadParams },
  TContext
> => {
  const mutationKey = ['markAsRead'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markAsRead>>,
    { id: number; params: MarkAsReadParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return markAsRead(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkAsReadMutationResult = NonNullable<Awaited<ReturnType<typeof markAsRead>>>;

export type MarkAsReadMutationError = unknown;

/**
 * @summary ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨
 */
export const useMarkAsRead = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markAsRead>>,
      TError,
      { id: number; params: MarkAsReadParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markAsRead>>,
  TError,
  { id: number; params: MarkAsReadParams },
  TContext
> => {
  const mutationOptions = getMarkAsReadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * S3Ïóê ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÍ∏∞ ÏúÑÌïú ÏûÑÏãú URL(Pre-signed URL)ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú Pre-signed URL ÏÉùÏÑ±
 */
export const generatePresignedUrl = (
  generatePresignedUrlRequest: GeneratePresignedUrlRequest,
  signal?: AbortSignal
) => {
  return customInstance<ApiResponseGeneratePresignedUrlResponse>({
    url: `/api/v1/media/presigned-url`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: generatePresignedUrlRequest,
    signal,
  });
};

export const getGeneratePresignedUrlMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generatePresignedUrl>>,
    TError,
    { data: GeneratePresignedUrlRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generatePresignedUrl>>,
  TError,
  { data: GeneratePresignedUrlRequest },
  TContext
> => {
  const mutationKey = ['generatePresignedUrl'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generatePresignedUrl>>,
    { data: GeneratePresignedUrlRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generatePresignedUrl(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GeneratePresignedUrlMutationResult = NonNullable<Awaited<ReturnType<typeof generatePresignedUrl>>>;
export type GeneratePresignedUrlMutationBody = GeneratePresignedUrlRequest;
export type GeneratePresignedUrlMutationError = unknown;

/**
 * @summary ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú Pre-signed URL ÏÉùÏÑ±
 */
export const useGeneratePresignedUrl = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generatePresignedUrl>>,
      TError,
      { data: GeneratePresignedUrlRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof generatePresignedUrl>>,
  TError,
  { data: GeneratePresignedUrlRequest },
  TContext
> => {
  const mutationOptions = getGeneratePresignedUrlMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎùºÏù¥ÎçîÍ∞Ä Î∞∞Îã¨ ÏöîÏ≤≠Ïóê ÎåÄÌï¥ ÏàòÎùΩ ÎòêÎäî Í±∞Ï†àÏùÑ Í≤∞Ï†ïÌï©ÎãàÎã§.
 * @summary ÎùºÏù¥Îçî Î∞∞Îã¨ ÏàòÎùΩ/Í±∞Ï†à Í≤∞Ï†ï
 */
export const decideOrderDelivery = (riderDecisionRequestDto: RiderDecisionRequestDto, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/decision`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: riderDecisionRequestDto,
    signal,
  });
};

export const getDecideOrderDeliveryMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof decideOrderDelivery>>,
    TError,
    { data: RiderDecisionRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof decideOrderDelivery>>,
  TError,
  { data: RiderDecisionRequestDto },
  TContext
> => {
  const mutationKey = ['decideOrderDelivery'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof decideOrderDelivery>>,
    { data: RiderDecisionRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return decideOrderDelivery(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DecideOrderDeliveryMutationResult = NonNullable<Awaited<ReturnType<typeof decideOrderDelivery>>>;
export type DecideOrderDeliveryMutationBody = RiderDecisionRequestDto;
export type DecideOrderDeliveryMutationError = unknown;

/**
 * @summary ÎùºÏù¥Îçî Î∞∞Îã¨ ÏàòÎùΩ/Í±∞Ï†à Í≤∞Ï†ï
 */
export const useDecideOrderDelivery = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof decideOrderDelivery>>,
      TError,
      { data: RiderDecisionRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof decideOrderDelivery>>,
  TError,
  { data: RiderDecisionRequestDto },
  TContext
> => {
  const mutationOptions = getDecideOrderDeliveryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞Îã¨ Í∞ÄÎä• ÏßÄÏó≠ÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§ (ÌòÑÏû¨Îäî 1Íµ∞Îç∞Îßå, ÏûêÏú†Î°úÏö¥ ÌòïÏãùÏúºÎ°ú Í∞ÄÎä•).
 * @summary Î∞∞Îã¨ Í∞ÄÎä• ÏßÄÏó≠ ÏÑ§Ï†ï
 */
export const updateDeliveryArea = (deliveryAreaRequestDto: DeliveryAreaRequestDto, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/area`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: deliveryAreaRequestDto,
    signal,
  });
};

export const getUpdateDeliveryAreaMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeliveryArea>>,
    TError,
    { data: DeliveryAreaRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeliveryArea>>,
  TError,
  { data: DeliveryAreaRequestDto },
  TContext
> => {
  const mutationKey = ['updateDeliveryArea'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeliveryArea>>,
    { data: DeliveryAreaRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateDeliveryArea(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeliveryAreaMutationResult = NonNullable<Awaited<ReturnType<typeof updateDeliveryArea>>>;
export type UpdateDeliveryAreaMutationBody = DeliveryAreaRequestDto;
export type UpdateDeliveryAreaMutationError = unknown;

/**
 * @summary Î∞∞Îã¨ Í∞ÄÎä• ÏßÄÏó≠ ÏÑ§Ï†ï
 */
export const useUpdateDeliveryArea = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeliveryArea>>,
      TError,
      { data: DeliveryAreaRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeliveryArea>>,
  TError,
  { data: DeliveryAreaRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateDeliveryAreaMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÜåÎπÑÏûêÍ∞Ä Ï£ºÎ¨∏ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */
export const getAll = (params?: GetAllParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/customer/orders`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetAllInfiniteQueryKey = (params?: GetAllParams) => {
  return ['infinate', `/api/v1/customer/orders`, ...(params ? [params] : [])] as const;
};

export const getGetAllQueryKey = (params?: GetAllParams) => {
  return [`/api/v1/customer/orders`, ...(params ? [params] : [])] as const;
};

export const getGetAllInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
  TError = unknown,
>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllInfiniteQueryError = unknown;

export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params: undefined | GetAllParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllQueryOptions = <TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllQueryError = unknown;

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params: undefined | GetAllParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÜåÎπÑÏûêÍ∞Ä ÏÉÅÏ†êÏóê Ï£ºÎ¨∏ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÏÉùÏÑ±
 */
export const create = (orderCreateRequest: OrderCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({
    url: `/api/v1/customer/orders`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderCreateRequest,
    signal,
  });
};

export const getCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext> => {
  const mutationKey = ['create'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof create>>, { data: OrderCreateRequest }> = (props) => {
    const { data } = props ?? {};

    return create(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMutationResult = NonNullable<Awaited<ReturnType<typeof create>>>;
export type CreateMutationBody = OrderCreateRequest;
export type CreateMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ ÏÉùÏÑ±
 */
export const useCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext> => {
  const mutationOptions = getCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÜåÎπÑÏûêÍ∞Ä ÏÉÅÏ†êÏóêÏÑú Ï£ºÎ¨∏ ÏàòÎùΩ Ï†ÑÏù∏ Ï£ºÎ¨∏ÏùÑ Ï∑®ÏÜåÌïòÎäî Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ Ï∑®ÏÜå
 */
export const cancel = (orderId: number, orderCancelRequest: OrderCancelRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({
    url: `/api/v1/customer/orders/${orderId}/cancel`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderCancelRequest,
    signal,
  });
};

export const getCancelMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancel>>,
    TError,
    { orderId: number; data: OrderCancelRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancel>>,
  TError,
  { orderId: number; data: OrderCancelRequest },
  TContext
> => {
  const mutationKey = ['cancel'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancel>>,
    { orderId: number; data: OrderCancelRequest }
  > = (props) => {
    const { orderId, data } = props ?? {};

    return cancel(orderId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelMutationResult = NonNullable<Awaited<ReturnType<typeof cancel>>>;
export type CancelMutationBody = OrderCancelRequest;
export type CancelMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ Ï∑®ÏÜå
 */
export const useCancel = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancel>>,
      TError,
      { orderId: number; data: OrderCancelRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancel>>,
  TError,
  { orderId: number; data: OrderCancelRequest },
  TContext
> => {
  const mutationOptions = getCancelMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÜåÎπÑÏûêÍ∞Ä ÏÉùÏÑ±Ìïú Ï£ºÎ¨∏Ïùò Í≤∞Ï†ú ÏãúÎèÑ
 * @summary Ï£ºÎ¨∏ Í≤∞Ï†ú
 */
export const pay = (merchantUid: string, orderPayRequest: OrderPayRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({
    url: `/api/v1/customer/orders/${merchantUid}/pay`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderPayRequest,
    signal,
  });
};

export const getPayMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pay>>,
    TError,
    { merchantUid: string; data: OrderPayRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pay>>,
  TError,
  { merchantUid: string; data: OrderPayRequest },
  TContext
> => {
  const mutationKey = ['pay'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pay>>,
    { merchantUid: string; data: OrderPayRequest }
  > = (props) => {
    const { merchantUid, data } = props ?? {};

    return pay(merchantUid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PayMutationResult = NonNullable<Awaited<ReturnType<typeof pay>>>;
export type PayMutationBody = OrderPayRequest;
export type PayMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ Í≤∞Ï†ú
 */
export const usePay = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof pay>>,
      TError,
      { merchantUid: string; data: OrderPayRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof pay>>,
  TError,
  { merchantUid: string; data: OrderPayRequest },
  TContext
> => {
  const mutationOptions = getPayMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const signup = (signupRequest: SignupRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseSignupResponse>({
    url: `/api/v1/auth/signup`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: signupRequest,
    signal,
  });
};

export const getSignupMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext> => {
  const mutationKey = ['signup'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signup>>, { data: SignupRequest }> = (props) => {
    const { data } = props ?? {};

    return signup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignupMutationResult = NonNullable<Awaited<ReturnType<typeof signup>>>;
export type SignupMutationBody = SignupRequest;
export type SignupMutationError = unknown;

export const useSignup = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext> => {
  const mutationOptions = getSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const logout = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/auth/logout`, method: 'POST', signal });
};

export const getLogoutMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationKey = ['logout'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
    return logout();
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError = unknown;

export const useLogout = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const login = (loginRequest: LoginRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseLoginResponse>({
    url: `/api/v1/auth/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: loginRequest,
    signal,
  });
};

export const getLoginMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext> => {
  const mutationKey = ['login'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginRequest }> = (props) => {
    const { data } = props ?? {};

    return login(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = LoginRequest;
export type LoginMutationError = unknown;

export const useLogin = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ÏùÑ Í±∞Ï†àÌïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ Í±∞Ï†à
 */
export const rejectOrder = (storeId: number, orderId: number) => {
  return customInstance<ApiResponseOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/${orderId}/reject`,
    method: 'PATCH',
  });
};

export const getRejectOrderMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectOrder>>,
    TError,
    { storeId: number; orderId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationKey = ['rejectOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectOrder>>, { storeId: number; orderId: number }> = (
    props
  ) => {
    const { storeId, orderId } = props ?? {};

    return rejectOrder(storeId, orderId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RejectOrderMutationResult = NonNullable<Awaited<ReturnType<typeof rejectOrder>>>;

export type RejectOrderMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ Í±∞Ï†à
 */
export const useRejectOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectOrder>>,
      TError,
      { storeId: number; orderId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rejectOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationOptions = getRejectOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ÏùÑ ÏàòÎùΩÌïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ
 */
export const acceptOrder = (storeId: number, orderId: number) => {
  return customInstance<ApiResponseOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/${orderId}/accept`,
    method: 'PATCH',
  });
};

export const getAcceptOrderMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptOrder>>,
    TError,
    { storeId: number; orderId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof acceptOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationKey = ['acceptOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof acceptOrder>>, { storeId: number; orderId: number }> = (
    props
  ) => {
    const { storeId, orderId } = props ?? {};

    return acceptOrder(storeId, orderId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AcceptOrderMutationResult = NonNullable<Awaited<ReturnType<typeof acceptOrder>>>;

export type AcceptOrderMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ
 */
export const useAcceptOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof acceptOrder>>,
      TError,
      { storeId: number; orderId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof acceptOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationOptions = getAcceptOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î¶¨Î∑∞ idÎ°ú Î¶¨Î∑∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï°∞Ìöå
 */
export const getReview = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewResponse>({ url: `/api/v1/reviews/${reviewId}`, method: 'GET', signal });
};

export const getGetReviewInfiniteQueryKey = (reviewId?: number) => {
  return ['infinate', `/api/v1/reviews/${reviewId}`] as const;
};

export const getGetReviewQueryKey = (reviewId?: number) => {
  return [`/api/v1/reviews/${reviewId}`] as const;
};

export const getGetReviewInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewInfiniteQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReview>>> = ({ signal }) => getReview(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReview>>>;
export type GetReviewInfiniteQueryError = unknown;

export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReview>>, TError, Awaited<ReturnType<typeof getReview>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReview>>,
          TError,
          Awaited<ReturnType<typeof getReview>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï°∞Ìöå
 */

export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewInfiniteQueryOptions(reviewId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetReviewQueryOptions = <TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReview>>> = ({ signal }) => getReview(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewQueryResult = NonNullable<Awaited<ReturnType<typeof getReview>>>;
export type GetReviewQueryError = unknown;

export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReview>>, TError, Awaited<ReturnType<typeof getReview>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReview>>,
          TError,
          Awaited<ReturnType<typeof getReview>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï°∞Ìöå
 */

export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewQueryOptions(reviewId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î¶¨Î∑∞Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ ÏÇ≠Ï†ú
 */
export const deleteReview = (reviewId: number) => {
  return customInstance<ApiResponseString>({ url: `/api/v1/reviews/${reviewId}`, method: 'DELETE' });
};

export const getDeleteReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['deleteReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return deleteReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteReviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReview>>>;

export type DeleteReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ ÏÇ≠Ï†ú
 */
export const useDeleteReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getDeleteReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î¶¨Î∑∞Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ ÏàòÏ†ï
 */
export const updateReview = (reviewId: number, reviewUpdateRequest: ReviewUpdateRequest) => {
  return customInstance<ApiResponseReviewResponse>({
    url: `/api/v1/reviews/${reviewId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: reviewUpdateRequest,
  });
};

export const getUpdateReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateReview>>,
    TError,
    { reviewId: number; data: ReviewUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateReview>>,
  TError,
  { reviewId: number; data: ReviewUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateReview>>,
    { reviewId: number; data: ReviewUpdateRequest }
  > = (props) => {
    const { reviewId, data } = props ?? {};

    return updateReview(reviewId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateReview>>>;
export type UpdateReviewMutationBody = ReviewUpdateRequest;
export type UpdateReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ ÏàòÏ†ï
 */
export const useUpdateReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateReview>>,
      TError,
      { reviewId: number; data: ReviewUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateReview>>,
  TError,
  { reviewId: number; data: ReviewUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞Îã¨ IDÏôÄ Îã§Ïùå ÏÉÅÌÉúÎ•º Î∞õÏïÑ Î∞∞Îã¨ ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const updateStatus = (deliveryId: number, params: UpdateStatusParams) => {
  return customInstance<void>({ url: `/api/v1/deliveries/${deliveryId}/delivery-status`, method: 'PATCH', params });
};

export const getUpdateStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStatus>>,
    TError,
    { deliveryId: number; params: UpdateStatusParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStatus>>,
  TError,
  { deliveryId: number; params: UpdateStatusParams },
  TContext
> => {
  const mutationKey = ['updateStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStatus>>,
    { deliveryId: number; params: UpdateStatusParams }
  > = (props) => {
    const { deliveryId, params } = props ?? {};

    return updateStatus(deliveryId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateStatus>>>;

export type UpdateStatusMutationError = unknown;

/**
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useUpdateStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateStatus>>,
      TError,
      { deliveryId: number; params: UpdateStatusParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateStatus>>,
  TError,
  { deliveryId: number; params: UpdateStatusParams },
  TContext
> => {
  const mutationOptions = getUpdateStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎùºÏù¥Îçî ÌÜ†Í∏Ä Ï†ÑÌôòÏúºÎ°ú ÏÉÅÌÉúÎ•º Ï†ÑÌôòÌï©ÎãàÎã§.
 * @summary ÎùºÏù¥Îçî ÌÜ†Í∏Ä Ï†ÑÌôò
 */
export const updateRiderStatus = (riderToggleStatusRequestDto: RiderToggleStatusRequestDto) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/status`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: riderToggleStatusRequestDto,
  });
};

export const getUpdateRiderStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRiderStatus>>,
    TError,
    { data: RiderToggleStatusRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRiderStatus>>,
  TError,
  { data: RiderToggleStatusRequestDto },
  TContext
> => {
  const mutationKey = ['updateRiderStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRiderStatus>>,
    { data: RiderToggleStatusRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateRiderStatus(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRiderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateRiderStatus>>>;
export type UpdateRiderStatusMutationBody = RiderToggleStatusRequestDto;
export type UpdateRiderStatusMutationError = unknown;

/**
 * @summary ÎùºÏù¥Îçî ÌÜ†Í∏Ä Ï†ÑÌôò
 */
export const useUpdateRiderStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRiderStatus>>,
      TError,
      { data: RiderToggleStatusRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateRiderStatus>>,
  TError,
  { data: RiderToggleStatusRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateRiderStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * sort, cursor, size Î•º Î∞õÏïÑ ÌäπÏ†ï ÏÉÅÏ†êÏùò Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌäπÏ†ï ÏÉÅÏ†ê Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getStoreReviews = (storeId: number, params: GetStoreReviewsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseReviewResponse>({
    url: `/api/v1/stores/${storeId}/reviews`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetStoreReviewsInfiniteQueryKey = (storeId?: number, params?: GetStoreReviewsParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetStoreReviewsQueryKey = (storeId?: number, params?: GetStoreReviewsParams) => {
  return [`/api/v1/stores/${storeId}/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetStoreReviewsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreReviewsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreReviews>>> = ({ signal }) =>
    getStoreReviews(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getStoreReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreReviews>>>;
export type GetStoreReviewsInfiniteQueryError = unknown;

export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌäπÏ†ï ÏÉÅÏ†ê Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreReviewsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetStoreReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreReviewsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreReviews>>> = ({ signal }) =>
    getStoreReviews(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStoreReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreReviews>>>;
export type GetStoreReviewsQueryError = unknown;

export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌäπÏ†ï ÏÉÅÏ†ê Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreReviewsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ùÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
 */
export const getPendingOrders = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/pending`,
    method: 'GET',
    signal,
  });
};

export const getGetPendingOrdersInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/pending`] as const;
};

export const getGetPendingOrdersQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}/orders/pending`] as const;
};

export const getGetPendingOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingOrdersInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingOrders>>> = ({ signal }) =>
    getPendingOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPendingOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingOrders>>>;
export type GetPendingOrdersInfiniteQueryError = unknown;

export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPendingOrdersInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPendingOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingOrdersQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingOrders>>> = ({ signal }) =>
    getPendingOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPendingOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingOrders>>>;
export type GetPendingOrdersQueryError = unknown;

export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPendingOrdersQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌåêÎß§ÏûêÍ∞Ä Ï£ºÎ¨∏ Ïù¥Î†•ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */
export const getOrdersHistory = (storeId: number, params?: GetOrdersHistoryParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/history`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetOrdersHistoryInfiniteQueryKey = (storeId?: number, params?: GetOrdersHistoryParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/history`, ...(params ? [params] : [])] as const;
};

export const getGetOrdersHistoryQueryKey = (storeId?: number, params?: GetOrdersHistoryParams) => {
  return [`/api/v1/stores/${storeId}/orders/history`, ...(params ? [params] : [])] as const;
};

export const getGetOrdersHistoryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrdersHistoryInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersHistory>>> = ({ signal }) =>
    getOrdersHistory(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getOrdersHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrdersHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersHistory>>>;
export type GetOrdersHistoryInfiniteQueryError = unknown;

export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params: undefined | GetOrdersHistoryParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetOrdersHistoryInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetOrdersHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrdersHistoryQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersHistory>>> = ({ signal }) =>
    getOrdersHistory(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrdersHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrdersHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersHistory>>>;
export type GetOrdersHistoryQueryError = unknown;

export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params: undefined | GetOrdersHistoryParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetOrdersHistoryQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ Ï≤òÎ¶¨ Ï§ëÏù∏ Î™©Î°ùÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÌòÑÌô© Î™©Î°ù Ï°∞Ìöå
 */
export const getAcceptedOrders = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/accepted`,
    method: 'GET',
    signal,
  });
};

export const getGetAcceptedOrdersInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/accepted`] as const;
};

export const getGetAcceptedOrdersQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}/orders/accepted`] as const;
};

export const getGetAcceptedOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAcceptedOrdersInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcceptedOrders>>> = ({ signal }) =>
    getAcceptedOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAcceptedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAcceptedOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAcceptedOrders>>>;
export type GetAcceptedOrdersInfiniteQueryError = unknown;

export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÌòÑÌô© Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcceptedOrdersInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAcceptedOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAcceptedOrders>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAcceptedOrdersQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcceptedOrders>>> = ({ signal }) =>
    getAcceptedOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAcceptedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAcceptedOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getAcceptedOrders>>>;
export type GetAcceptedOrdersQueryError = unknown;

export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÌòÑÌô© Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcceptedOrdersQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ Ï£ºÍ∞ÑÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */
export const getWeekSettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/week`,
    method: 'GET',
    signal,
  });
};

export const getGetWeekSettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/week`] as const;
};

export const getGetWeekSettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/week`] as const;
};

export const getGetWeekSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements>>> = ({ signal }) =>
    getWeekSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements>>>;
export type GetWeekSettlementsInfiniteQueryError = unknown;

export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetWeekSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getWeekSettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements>>> = ({ signal }) =>
    getWeekSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements>>>;
export type GetWeekSettlementsQueryError = unknown;

export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ ÌäπÏ†ï Í∏∞Í∞ÑÏùò Ï†ïÏÇ∞ Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */
export const getPeriodSettlements = (storeId: number, params: GetPeriodSettlementsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/period`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetPeriodSettlementsInfiniteQueryKey = (storeId?: number, params?: GetPeriodSettlementsParams) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlementsQueryKey = (storeId?: number, params?: GetPeriodSettlementsParams) => {
  return [`/api/v1/store/settlements/${storeId}/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlementsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements>>> = ({ signal }) =>
    getPeriodSettlements(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements>>>;
export type GetPeriodSettlementsInfiniteQueryError = unknown;

export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlementsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPeriodSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPeriodSettlements>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlementsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements>>> = ({ signal }) =>
    getPeriodSettlements(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements>>>;
export type GetPeriodSettlementsQueryError = unknown;

export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlementsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ ÏõîÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */
export const getMonthSettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/month`,
    method: 'GET',
    signal,
  });
};

export const getGetMonthSettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/month`] as const;
};

export const getGetMonthSettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/month`] as const;
};

export const getGetMonthSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements>>> = ({ signal }) =>
    getMonthSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements>>>;
export type GetMonthSettlementsInfiniteQueryError = unknown;

export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMonthSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMonthSettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements>>> = ({ signal }) =>
    getMonthSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements>>>;
export type GetMonthSettlementsQueryError = unknown;

export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ ÏùºÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */
export const getDaySettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/day`,
    method: 'GET',
    signal,
  });
};

export const getGetDaySettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/day`] as const;
};

export const getGetDaySettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/day`] as const;
};

export const getGetDaySettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements>>> = ({ signal }) =>
    getDaySettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements>>>;
export type GetDaySettlementsInfiniteQueryError = unknown;

export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDaySettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDaySettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements>>> = ({ signal }) =>
    getDaySettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements>>>;
export type GetDaySettlementsQueryError = unknown;

export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î™®Îì† ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */
export const getCategories = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListStoreCategoryResponse>({
    url: `/api/v1/store-categories`,
    method: 'GET',
    signal,
  });
};

export const getGetCategoriesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/store-categories`] as const;
};

export const getGetCategoriesQueryKey = () => {
  return [`/api/v1/store-categories`] as const;
};

export const getGetCategoriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesInfiniteQueryError = unknown;

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesQueryError = unknown;

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchStores = (params: SearchStoresParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseStoreSearchResponse>({
    url: `/api/v1/search/stores`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSearchStoresInfiniteQueryKey = (params?: SearchStoresParams) => {
  return ['infinate', `/api/v1/search/stores`, ...(params ? [params] : [])] as const;
};

export const getSearchStoresQueryKey = (params?: SearchStoresParams) => {
  return [`/api/v1/search/stores`, ...(params ? [params] : [])] as const;
};

export const getSearchStoresInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStoresInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStores>>> = ({ signal }) => searchStores(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchStores>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchStoresInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchStores>>>;
export type SearchStoresInfiniteQueryError = unknown;

export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchStoresInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchStoresQueryOptions = <TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStoresQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStores>>> = ({ signal }) => searchStores(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchStores>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchStoresQueryResult = NonNullable<Awaited<ReturnType<typeof searchStores>>>;
export type SearchStoresQueryError = unknown;

export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchStoresQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ Ï£ºÍ∞ÑÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */
export const getWeekSettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/week`,
    method: 'GET',
    signal,
  });
};

export const getGetWeekSettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/week`] as const;
};

export const getGetWeekSettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/week`] as const;
};

export const getGetWeekSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements1>>> = ({ signal }) =>
    getWeekSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements1>>>;
export type GetWeekSettlements1InfiniteQueryError = unknown;

export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetWeekSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getWeekSettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements1>>> = ({ signal }) =>
    getWeekSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements1>>>;
export type GetWeekSettlements1QueryError = unknown;

export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ Ï†ïÏÇ∞ ÏöîÏïΩ Ïπ¥Îìú Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏöîÏïΩ Ï°∞Ìöå
 */
export const getSummary = (signal?: AbortSignal) => {
  return customInstance<ApiResponseSummaryResponse>({
    url: `/api/v1/rider/settlements/summary`,
    method: 'GET',
    signal,
  });
};

export const getGetSummaryInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/summary`] as const;
};

export const getGetSummaryQueryKey = () => {
  return [`/api/v1/rider/settlements/summary`] as const;
};

export const getGetSummaryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSummaryInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSummary>>> = ({ signal }) => getSummary(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSummaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSummary>>>;
export type GetSummaryInfiniteQueryError = unknown;

export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏöîÏïΩ Ï°∞Ìöå
 */

export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSummaryInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSummaryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSummary>>> = ({ signal }) => getSummary(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getSummary>>>;
export type GetSummaryQueryError = unknown;

export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏöîÏïΩ Ï°∞Ìöå
 */

export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSummaryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ ÌäπÏ†ï Í∏∞Í∞ÑÏùò Ï†ïÏÇ∞ Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */
export const getPeriodSettlements1 = (params: GetPeriodSettlements1Params, signal?: AbortSignal) => {
  return customInstance<ApiResponseSettlementResponse>({
    url: `/api/v1/rider/settlements/period`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetPeriodSettlements1InfiniteQueryKey = (params?: GetPeriodSettlements1Params) => {
  return ['infinate', `/api/v1/rider/settlements/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlements1QueryKey = (params?: GetPeriodSettlements1Params) => {
  return [`/api/v1/rider/settlements/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlements1InfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements1>>> = ({ signal }) =>
    getPeriodSettlements1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements1>>>;
export type GetPeriodSettlements1InfiniteQueryError = unknown;

export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlements1InfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPeriodSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getPeriodSettlements1>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlements1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements1>>> = ({ signal }) =>
    getPeriodSettlements1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements1>>>;
export type GetPeriodSettlements1QueryError = unknown;

export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlements1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ ÏõîÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */
export const getMonthSettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/month`,
    method: 'GET',
    signal,
  });
};

export const getGetMonthSettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/month`] as const;
};

export const getGetMonthSettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/month`] as const;
};

export const getGetMonthSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements1>>> = ({ signal }) =>
    getMonthSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements1>>>;
export type GetMonthSettlements1InfiniteQueryError = unknown;

export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMonthSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getMonthSettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements1>>> = ({ signal }) =>
    getMonthSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements1>>>;
export type GetMonthSettlements1QueryError = unknown;

export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ ÏùºÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */
export const getDaySettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/day`,
    method: 'GET',
    signal,
  });
};

export const getGetDaySettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/day`] as const;
};

export const getGetDaySettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/day`] as const;
};

export const getGetDaySettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements1>>> = ({ signal }) =>
    getDaySettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements1>>>;
export type GetDaySettlements1InfiniteQueryError = unknown;

export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDaySettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getDaySettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements1>>> = ({ signal }) =>
    getDaySettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements1>>>;
export type GetDaySettlements1QueryError = unknown;

export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï Î¶¨Î∑∞Ïóê Îã¨Î¶∞ Ï¢ãÏïÑÏöîÏùò ÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ïàò Ï°∞Ìöå
 */
export const getReviewLikeCount = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewLikeResponse>({
    url: `/api/v1/reviews/${reviewId}/likes`,
    method: 'GET',
    signal,
  });
};

export const getGetReviewLikeCountInfiniteQueryKey = (reviewId?: number) => {
  return ['infinate', `/api/v1/reviews/${reviewId}/likes`] as const;
};

export const getGetReviewLikeCountQueryKey = (reviewId?: number) => {
  return [`/api/v1/reviews/${reviewId}/likes`] as const;
};

export const getGetReviewLikeCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewLikeCountInfiniteQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewLikeCount>>> = ({ signal }) =>
    getReviewLikeCount(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReviewLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewLikeCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewLikeCount>>>;
export type GetReviewLikeCountInfiniteQueryError = unknown;

export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ïàò Ï°∞Ìöå
 */

export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewLikeCountInfiniteQueryOptions(reviewId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetReviewLikeCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getReviewLikeCount>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewLikeCountQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewLikeCount>>> = ({ signal }) =>
    getReviewLikeCount(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReviewLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewLikeCountQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewLikeCount>>>;
export type GetReviewLikeCountQueryError = unknown;

export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ïàò Ï°∞Ìöå
 */

export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewLikeCountQueryOptions(reviewId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÏïåÎ¶º Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. isRead ÌååÎùºÎØ∏ÌÑ∞Î°ú ÏùΩÏùå/ÏïàÏùΩÏùå ÌïÑÌÑ∞ÎßÅÏù¥ Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏïåÎ¶º Î™©Î°ù Ï°∞Ìöå
 */
export const getNotifications = (params: GetNotificationsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseListNotification>({ url: `/api/v1/notifications`, method: 'GET', params, signal });
};

export const getGetNotificationsInfiniteQueryKey = (params?: GetNotificationsParams) => {
  return ['infinate', `/api/v1/notifications`, ...(params ? [params] : [])] as const;
};

export const getGetNotificationsQueryKey = (params?: GetNotificationsParams) => {
  return [`/api/v1/notifications`, ...(params ? [params] : [])] as const;
};

export const getGetNotificationsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) =>
    getNotifications(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>;
export type GetNotificationsInfiniteQueryError = unknown;

export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params: GetNotificationsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params: GetNotificationsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏïåÎ¶º Î™©Î°ù Ï°∞Ìöå
 */

export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetNotificationsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) =>
    getNotifications(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>;
export type GetNotificationsQueryError = unknown;

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params: GetNotificationsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params: GetNotificationsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏïåÎ¶º Î™©Î°ù Ï°∞Ìöå
 */

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetNotificationsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º ÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º Ïàò Ï°∞Ìöå
 */
export const getUnreadCount = (params: GetUnreadCountParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseLong>({ url: `/api/v1/notifications/unread-count`, method: 'GET', params, signal });
};

export const getGetUnreadCountInfiniteQueryKey = (params?: GetUnreadCountParams) => {
  return ['infinate', `/api/v1/notifications/unread-count`, ...(params ? [params] : [])] as const;
};

export const getGetUnreadCountQueryKey = (params?: GetUnreadCountParams) => {
  return [`/api/v1/notifications/unread-count`, ...(params ? [params] : [])] as const;
};

export const getGetUnreadCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  params: GetUnreadCountParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCount>>> = ({ signal }) =>
    getUnreadCount(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCount>>>;
export type GetUnreadCountInfiniteQueryError = unknown;

export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  params: GetUnreadCountParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  params: GetUnreadCountParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  params: GetUnreadCountParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º Ïàò Ï°∞Ìöå
 */

export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  params: GetUnreadCountParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUnreadCountQueryOptions = <TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  params: GetUnreadCountParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCount>>> = ({ signal }) =>
    getUnreadCount(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCount>>>;
export type GetUnreadCountQueryError = unknown;

export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  params: GetUnreadCountParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  params: GetUnreadCountParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  params: GetUnreadCountParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º Ïàò Ï°∞Ìöå
 */

export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  params: GetUnreadCountParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * SSEÎ•º ÌÜµÌï¥ Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏùÑ Íµ¨ÎèÖÌï©ÎãàÎã§. Í∞Å Í∏∞Í∏∞Î≥ÑÎ°ú Í≥†Ïú†Ìïú deviceIdÎ•º Ìó§Îçî(X-Device-ID)Ïóê Îã¥ÏïÑ ÏöîÏ≤≠Ìï¥Ïïº Ìï©ÎãàÎã§.
 * @summary SSE Íµ¨ÎèÖ
 */
export const subscribe = (params: SubscribeParams, signal?: AbortSignal) => {
  return customInstance<SseEmitter>({ url: `/api/v1/notifications/stream`, method: 'GET', params, signal });
};

export const getSubscribeInfiniteQueryKey = (params?: SubscribeParams) => {
  return ['infinate', `/api/v1/notifications/stream`, ...(params ? [params] : [])] as const;
};

export const getSubscribeQueryKey = (params?: SubscribeParams) => {
  return [`/api/v1/notifications/stream`, ...(params ? [params] : [])] as const;
};

export const getSubscribeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>,
  TError = unknown,
>(
  params: SubscribeParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSubscribeInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof subscribe>>> = ({ signal }) => subscribe(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof subscribe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SubscribeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof subscribe>>>;
export type SubscribeInfiniteQueryError = unknown;

export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  params: SubscribeParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof subscribe>>, TError, Awaited<ReturnType<typeof subscribe>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  params: SubscribeParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscribe>>,
          TError,
          Awaited<ReturnType<typeof subscribe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  params: SubscribeParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary SSE Íµ¨ÎèÖ
 */

export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  params: SubscribeParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSubscribeInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSubscribeQueryOptions = <TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  params: SubscribeParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSubscribeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof subscribe>>> = ({ signal }) => subscribe(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof subscribe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SubscribeQueryResult = NonNullable<Awaited<ReturnType<typeof subscribe>>>;
export type SubscribeQueryError = unknown;

export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  params: SubscribeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof subscribe>>, TError, Awaited<ReturnType<typeof subscribe>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  params: SubscribeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscribe>>,
          TError,
          Awaited<ReturnType<typeof subscribe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  params: SubscribeParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary SSE Íµ¨ÎèÖ
 */

export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  params: SubscribeParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSubscribeQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩÍ≥º Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§. cursor Í∏∞Î∞ò ÌéòÏù¥ÏßïÏùÑ ÏßÄÏõêÌï©ÎãàÎã§. filter: LATEST(ÏµúÏã†Ïàú), OLDEST(Ïò§ÎûòÎêúÏàú)
 * @summary Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩ Ï°∞Ìöå + Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getTotalDeliveries = (params?: GetTotalDeliveriesParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseDeliveredSummaryResponseDto>({
    url: `/api/v1/deliveries/total`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetTotalDeliveriesInfiniteQueryKey = (params?: GetTotalDeliveriesParams) => {
  return ['infinate', `/api/v1/deliveries/total`, ...(params ? [params] : [])] as const;
};

export const getGetTotalDeliveriesQueryKey = (params?: GetTotalDeliveriesParams) => {
  return [`/api/v1/deliveries/total`, ...(params ? [params] : [])] as const;
};

export const getGetTotalDeliveriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalDeliveriesInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTotalDeliveries>>> = ({ signal }) =>
    getTotalDeliveries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTotalDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTotalDeliveries>>>;
export type GetTotalDeliveriesInfiniteQueryError = unknown;

export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params: undefined | GetTotalDeliveriesParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩ Ï°∞Ìöå + Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTotalDeliveriesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTotalDeliveriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTotalDeliveries>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalDeliveriesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTotalDeliveries>>> = ({ signal }) =>
    getTotalDeliveries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTotalDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getTotalDeliveries>>>;
export type GetTotalDeliveriesQueryError = unknown;

export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params: undefined | GetTotalDeliveriesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩ Ï°∞Ìöå + Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTotalDeliveriesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò Ïò§Îäò Î∞∞Îã¨ ÎÇ¥Ïó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïò§ÎäòÏùò Î∞∞Îã¨ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */
export const getTodayDeliveries = (signal?: AbortSignal) => {
  return customInstance<ApiResponseTodayDeliveringResponseDto>({
    url: `/api/v1/deliveries/today`,
    method: 'GET',
    signal,
  });
};

export const getGetTodayDeliveriesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/deliveries/today`] as const;
};

export const getGetTodayDeliveriesQueryKey = () => {
  return [`/api/v1/deliveries/today`] as const;
};

export const getGetTodayDeliveriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTodayDeliveriesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodayDeliveries>>> = ({ signal }) =>
    getTodayDeliveries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTodayDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTodayDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTodayDeliveries>>>;
export type GetTodayDeliveriesInfiniteQueryError = unknown;

export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ïò§ÎäòÏùò Î∞∞Îã¨ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTodayDeliveriesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTodayDeliveriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTodayDeliveries>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTodayDeliveriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodayDeliveries>>> = ({ signal }) =>
    getTodayDeliveries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTodayDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTodayDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getTodayDeliveries>>>;
export type GetTodayDeliveriesQueryError = unknown;

export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ïò§ÎäòÏùò Î∞∞Îã¨ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTodayDeliveriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ ÎÇ¥Ïó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. (ÎèôÏ†Å riderProfile ID ÌïÑÏöîÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∏°ÏóêÏÑú 1Î∂ÑÏóê Ìïú Î≤àÏî© Ìè¥ÎßÅ Í∂åÏû•)
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Ï°∞Ìöå
 */
export const getInProgressDelivery = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListCurrentDeliveringResponseDto>({
    url: `/api/v1/deliveries/in-progress`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressDeliveryInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/deliveries/in-progress`] as const;
};

export const getGetInProgressDeliveryQueryKey = () => {
  return [`/api/v1/deliveries/in-progress`] as const;
};

export const getGetInProgressDeliveryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDeliveryInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDelivery>>> = ({ signal }) =>
    getInProgressDelivery(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDeliveryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressDelivery>>>;
export type GetInProgressDeliveryInfiniteQueryError = unknown;

export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Ï°∞Ìöå
 */

export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDeliveryInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressDeliveryQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressDelivery>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDeliveryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDelivery>>> = ({ signal }) =>
    getInProgressDelivery(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDeliveryQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressDelivery>>>;
export type GetInProgressDeliveryQueryError = unknown;

export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Ï°∞Ìöå
 */

export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDeliveryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò ÏßÑÌñâ Ï§ëÏù∏ Îã®Ïùº Î∞∞Îã¨ ÎÇ¥Ïó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. (ÎèôÏ†Å riderProfile ID ÌïÑÏöîÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∏°ÏóêÏÑú 1Î∂ÑÏóê Ìïú Î≤àÏî© Ìè¥ÎßÅ Í∂åÏû•)
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Îã®Í±¥ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getInProgressDetailDelivery = (deliveryId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseCurrentDeliveringDetailsDto>({
    url: `/api/v1/deliveries/in-progress/${deliveryId}`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressDetailDeliveryInfiniteQueryKey = (deliveryId?: number) => {
  return ['infinate', `/api/v1/deliveries/in-progress/${deliveryId}`] as const;
};

export const getGetInProgressDetailDeliveryQueryKey = (deliveryId?: number) => {
  return [`/api/v1/deliveries/in-progress/${deliveryId}`] as const;
};

export const getGetInProgressDetailDeliveryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDetailDeliveryInfiniteQueryKey(deliveryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDetailDelivery>>> = ({ signal }) =>
    getInProgressDetailDelivery(deliveryId, signal);

  return { queryKey, queryFn, enabled: !!deliveryId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDetailDeliveryInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInProgressDetailDelivery>>
>;
export type GetInProgressDetailDeliveryInfiniteQueryError = unknown;

export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Îã®Í±¥ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDetailDeliveryInfiniteQueryOptions(deliveryId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressDetailDeliveryQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDetailDeliveryQueryKey(deliveryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDetailDelivery>>> = ({ signal }) =>
    getInProgressDetailDelivery(deliveryId, signal);

  return { queryKey, queryFn, enabled: !!deliveryId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDetailDeliveryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInProgressDetailDelivery>>
>;
export type GetInProgressDetailDeliveryQueryError = unknown;

export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Îã®Í±¥ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDetailDeliveryQueryOptions(deliveryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÜåÎπÑÏûêÍ∞Ä Ïñ¥Îñ§ Ï£ºÎ¨∏Ïùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */
export const get = (orderId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({ url: `/api/v1/customer/orders/${orderId}`, method: 'GET', signal });
};

export const getGetInfiniteQueryKey = (orderId?: number) => {
  return ['infinate', `/api/v1/customer/orders/${orderId}`] as const;
};

export const getGetQueryKey = (orderId?: number) => {
  return [`/api/v1/customer/orders/${orderId}`] as const;
};

export const getGetInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInfiniteQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetInfiniteQueryError = unknown;

export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */

export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInfiniteQueryOptions(orderId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetQueryError = unknown;

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetQueryOptions(orderId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
