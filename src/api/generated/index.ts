/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Î≠êÎì†Î∞∞Îã¨ API Î™ÖÏÑ∏ÏÑú
 * Î≠êÎì†Î∞∞Îã¨ API Î™ÖÏÑ∏ÏÑúÏûÖÎãàÎã§
 * OpenAPI spec version: v1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AccountInfoUpdateRequest,
  AddressCreateRequest,
  AddressUpdateRequest,
  ApiResponseAddressResponse,
  ApiResponseAvailableProfilesResponse,
  ApiResponseBoolean,
  ApiResponseCreateProfileResponse,
  ApiResponseCurrentDeliveringDetailsDto,
  ApiResponseCursorPageResponseOrderResponse,
  ApiResponseCursorPageResponseProductResponse,
  ApiResponseCursorPageResponseStoreSearchResponse,
  ApiResponseCustomerProfileResponse,
  ApiResponseDeliveredSummaryResponseDto,
  ApiResponseGeneratePresignedUrlResponse,
  ApiResponseListAddressResponse,
  ApiResponseListCurrentDeliveringResponseDto,
  ApiResponseListNotification,
  ApiResponseListOrderResponse,
  ApiResponseListSettlementResponse,
  ApiResponseListStoreCategoryResponse,
  ApiResponseLoginResponse,
  ApiResponseLong,
  ApiResponseOrderCreateResponse,
  ApiResponseOrderResponse,
  ApiResponsePasswordResetVerifyResponse,
  ApiResponseProductDetailResponse,
  ApiResponseProductResponse,
  ApiResponseReviewCreateResponse,
  ApiResponseReviewLikeResponse,
  ApiResponseReviewRatingAndListResponseDto,
  ApiResponseReviewResponse,
  ApiResponseRiderProfileResponse,
  ApiResponseSellerProfileResponse,
  ApiResponseSettlementResponse,
  ApiResponseSignupResponse,
  ApiResponseStoreResponse,
  ApiResponseString,
  ApiResponseSummaryResponse,
  ApiResponseSwitchProfileResponse,
  ApiResponseTodayDeliveringResponseDto,
  ApiResponseUserInfoResponse,
  ApiResponseVoid,
  BusinessInfoUpdateRequest,
  ChangePasswordRequest,
  CreateProfileRequest,
  CustomerProfileUpdateRequest,
  DeliveryAreaRequestDto,
  GeneratePresignedUrlRequest,
  GetAllParams,
  GetCompletedOrdersParams,
  GetMyReviewsParams,
  GetNotificationsParams,
  GetOrdersHistoryParams,
  GetPeriodSettlements1Params,
  GetPeriodSettlementsParams,
  GetStoreReviewsParams,
  GetTotalDeliveriesParams,
  LoginRequest,
  MyEmailVerifyRequest,
  OrderCancelRequest,
  OrderCreateRequest,
  OrderPayRequest,
  PasswordResetConfirmRequest,
  PasswordResetRequest,
  PasswordResetVerifyRequest,
  ProductCreateRequest,
  ProductUpdateRequest,
  ReviewCreateRequest,
  ReviewUpdateRequest,
  RiderAccountInfoUpdateRequest,
  RiderAreaUpdateRequest,
  RiderDecisionRequestDto,
  RiderProfileUpdateRequest,
  RiderStatusUpdateRequest,
  RiderToggleStatusRequestDto,
  SearchProductsParams,
  SearchStoresParams,
  SellerProfileUpdateRequest,
  SignupRequest,
  SseEmitter,
  StoreCreateRequest,
  StoreUpdateRequest,
  SwitchProfileRequest,
  UpdateStatusParams,
  UpdateUserRequest,
  VerificationSendRequest,
  VerificationVerifyRequest,
} from './model';

import { customInstance } from '../orval-mutator';
/**
 * ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export const getMyInfo = (signal?: AbortSignal) => {
  return customInstance<ApiResponseUserInfoResponse>({ url: `/api/v1/users/me`, method: 'GET', signal });
};

export const getGetMyInfoInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me`] as const;
};

export const getGetMyInfoQueryKey = () => {
  return [`/api/v1/users/me`] as const;
};

export const getGetMyInfoInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyInfoInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyInfo>>> = ({ signal }) => getMyInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyInfo>>>;
export type GetMyInfoInfiniteQueryError = unknown;

export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, Awaited<ReturnType<typeof getMyInfo>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyInfo>>,
          TError,
          Awaited<ReturnType<typeof getMyInfo>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetMyInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyInfo>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyInfoInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyInfoQueryOptions = <TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyInfo>>> = ({ signal }) => getMyInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getMyInfo>>>;
export type GetMyInfoQueryError = unknown;

export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, Awaited<ReturnType<typeof getMyInfo>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyInfo>>,
          TError,
          Awaited<ReturnType<typeof getMyInfo>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyInfoQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ, Ï†ÑÌôîÎ≤àÌò∏ Îì± Í∏∞Î≥∏ Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateMyInfo = (updateUserRequest: UpdateUserRequest) => {
  return customInstance<ApiResponseUserInfoResponse>({
    url: `/api/v1/users/me`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateUserRequest,
  });
};

export const getUpdateMyInfoMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyInfo>>,
    TError,
    { data: UpdateUserRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof updateMyInfo>>, TError, { data: UpdateUserRequest }, TContext> => {
  const mutationKey = ['updateMyInfo'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMyInfo>>, { data: UpdateUserRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return updateMyInfo(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateMyInfo>>>;
export type UpdateMyInfoMutationBody = UpdateUserRequest;
export type UpdateMyInfoMutationError = unknown;

/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateMyInfo = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyInfo>>,
      TError,
      { data: UpdateUserRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof updateMyInfo>>, TError, { data: UpdateUserRequest }, TContext> => {
  const mutationOptions = getUpdateMyInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ ÌôúÏÑ±ÌôîÎêú ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */
export const getMyProfile = (signal?: AbortSignal) => {
  return customInstance<ApiResponseSellerProfileResponse>({ url: `/api/v1/users/me/seller`, method: 'GET', signal });
};

export const getGetMyProfileInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/seller`] as const;
};

export const getGetMyProfileQueryKey = () => {
  return [`/api/v1/users/me/seller`] as const;
};

export const getGetMyProfileInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfileInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile>>> = ({ signal }) => getMyProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile>>>;
export type GetMyProfileInfiniteQueryError = unknown;

export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */

export function useGetMyProfileInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfileInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyProfile>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile>>> = ({ signal }) => getMyProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile>>>;
export type GetMyProfileQueryError = unknown;

export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */

export function useGetMyProfile<TData = Awaited<ReturnType<typeof getMyProfile>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfileQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑÏùò ÎãâÎÑ§ÏûÑ, ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÎÇ¥ ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑ ÏàòÏ†ï
 */
export const updateMyProfile = (sellerProfileUpdateRequest: SellerProfileUpdateRequest) => {
  return customInstance<ApiResponseSellerProfileResponse>({
    url: `/api/v1/users/me/seller`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: sellerProfileUpdateRequest,
  });
};

export const getUpdateMyProfileMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyProfile>>,
    TError,
    { data: SellerProfileUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMyProfile>>,
  TError,
  { data: SellerProfileUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateMyProfile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMyProfile>>,
    { data: SellerProfileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMyProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyProfileMutationResult = NonNullable<Awaited<ReturnType<typeof updateMyProfile>>>;
export type UpdateMyProfileMutationBody = SellerProfileUpdateRequest;
export type UpdateMyProfileMutationError = unknown;

/**
 * @summary ÎÇ¥ ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑ ÏàòÏ†ï
 */
export const useUpdateMyProfile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyProfile>>,
      TError,
      { data: SellerProfileUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMyProfile>>,
  TError,
  { data: SellerProfileUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateMyProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÇ¨ÏóÖÏûêÎ™Ö, ÏÇ¨ÏóÖÏûê Ï†ÑÌôîÎ≤àÌò∏Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÏÇ¨ÏóÖÏûê Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateBusinessInfo = (businessInfoUpdateRequest: BusinessInfoUpdateRequest) => {
  return customInstance<ApiResponseSellerProfileResponse>({
    url: `/api/v1/users/me/seller/business-info`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: businessInfoUpdateRequest,
  });
};

export const getUpdateBusinessInfoMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBusinessInfo>>,
    TError,
    { data: BusinessInfoUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBusinessInfo>>,
  TError,
  { data: BusinessInfoUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateBusinessInfo'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBusinessInfo>>,
    { data: BusinessInfoUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateBusinessInfo(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBusinessInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateBusinessInfo>>>;
export type UpdateBusinessInfoMutationBody = BusinessInfoUpdateRequest;
export type UpdateBusinessInfoMutationError = unknown;

/**
 * @summary ÏÇ¨ÏóÖÏûê Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateBusinessInfo = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBusinessInfo>>,
      TError,
      { data: BusinessInfoUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBusinessInfo>>,
  TError,
  { data: BusinessInfoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateBusinessInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏùÄÌñâÎ™Ö, Í≥ÑÏ¢åÎ≤àÌò∏, ÏòàÍ∏àÏ£ºÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ï†ïÏÇ∞ Í≥ÑÏ¢å Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateAccountInfo = (accountInfoUpdateRequest: AccountInfoUpdateRequest) => {
  return customInstance<ApiResponseSellerProfileResponse>({
    url: `/api/v1/users/me/seller/account-info`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: accountInfoUpdateRequest,
  });
};

export const getUpdateAccountInfoMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccountInfo>>,
    TError,
    { data: AccountInfoUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccountInfo>>,
  TError,
  { data: AccountInfoUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAccountInfo'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccountInfo>>,
    { data: AccountInfoUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccountInfo(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccountInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateAccountInfo>>>;
export type UpdateAccountInfoMutationBody = AccountInfoUpdateRequest;
export type UpdateAccountInfoMutationError = unknown;

/**
 * @summary Ï†ïÏÇ∞ Í≥ÑÏ¢å Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateAccountInfo = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAccountInfo>>,
      TError,
      { data: AccountInfoUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAccountInfo>>,
  TError,
  { data: AccountInfoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAccountInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ ÌôúÏÑ±ÌôîÎêú Î∞∞Îã¨Ïõê ÌîÑÎ°úÌïÑÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Î∞∞Îã¨Ïõê ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */
export const getMyProfile1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseRiderProfileResponse>({ url: `/api/v1/users/me/rider`, method: 'GET', signal });
};

export const getGetMyProfile1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/rider`] as const;
};

export const getGetMyProfile1QueryKey = () => {
  return [`/api/v1/users/me/rider`] as const;
};

export const getGetMyProfile1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile1>>> = ({ signal }) => getMyProfile1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyProfile1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile1>>>;
export type GetMyProfile1InfiniteQueryError = unknown;

export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Î∞∞Îã¨Ïõê ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */

export function useGetMyProfile1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyProfile1QueryOptions = <
  TData = Awaited<ReturnType<typeof getMyProfile1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile1>>> = ({ signal }) => getMyProfile1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyProfile1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile1QueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile1>>>;
export type GetMyProfile1QueryError = unknown;

export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile1>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Î∞∞Îã¨Ïõê ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */

export function useGetMyProfile1<TData = Awaited<ReturnType<typeof getMyProfile1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨Ïõê ÌîÑÎ°úÌïÑÏùò ÎãâÎÑ§ÏûÑ, ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Î∞∞Îã¨Ïõê ÌîÑÎ°úÌïÑ ÏàòÏ†ï
 */
export const updateMyProfile1 = (riderProfileUpdateRequest: RiderProfileUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderProfileUpdateRequest,
  });
};

export const getUpdateMyProfile1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyProfile1>>,
    TError,
    { data: RiderProfileUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMyProfile1>>,
  TError,
  { data: RiderProfileUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateMyProfile1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMyProfile1>>,
    { data: RiderProfileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMyProfile1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyProfile1MutationResult = NonNullable<Awaited<ReturnType<typeof updateMyProfile1>>>;
export type UpdateMyProfile1MutationBody = RiderProfileUpdateRequest;
export type UpdateMyProfile1MutationError = unknown;

/**
 * @summary ÎÇ¥ Î∞∞Îã¨Ïõê ÌîÑÎ°úÌïÑ ÏàòÏ†ï
 */
export const useUpdateMyProfile1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyProfile1>>,
      TError,
      { data: RiderProfileUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMyProfile1>>,
  TError,
  { data: RiderProfileUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateMyProfile1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞Îã¨ ÏÉÅÌÉúÎ•º ON ÎòêÎäî OFFÎ°ú ÏßÅÏ†ë ÏÑ§Ï†ïÌï©ÎãàÎã§.
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú ÏÑ§Ï†ï
 */
export const updateDeliveryStatus = (riderStatusUpdateRequest: RiderStatusUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/status`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderStatusUpdateRequest,
  });
};

export const getUpdateDeliveryStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeliveryStatus>>,
    TError,
    { data: RiderStatusUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeliveryStatus>>,
  TError,
  { data: RiderStatusUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateDeliveryStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeliveryStatus>>,
    { data: RiderStatusUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateDeliveryStatus(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeliveryStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateDeliveryStatus>>>;
export type UpdateDeliveryStatusMutationBody = RiderStatusUpdateRequest;
export type UpdateDeliveryStatusMutationError = unknown;

/**
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú ÏÑ§Ï†ï
 */
export const useUpdateDeliveryStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeliveryStatus>>,
      TError,
      { data: RiderStatusUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeliveryStatus>>,
  TError,
  { data: RiderStatusUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateDeliveryStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ ÏÑ§Ï†ïÎêú ÌôúÎèô ÏßÄÏó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌôúÎèô ÏßÄÏó≠ Ï°∞Ìöå
 */
export const getDeliveryArea = (signal?: AbortSignal) => {
  return customInstance<ApiResponseString>({ url: `/api/v1/users/me/rider/area`, method: 'GET', signal });
};

export const getGetDeliveryAreaInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/rider/area`] as const;
};

export const getGetDeliveryAreaQueryKey = () => {
  return [`/api/v1/users/me/rider/area`] as const;
};

export const getGetDeliveryAreaInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDeliveryAreaInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeliveryArea>>> = ({ signal }) => getDeliveryArea(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDeliveryArea>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDeliveryAreaInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDeliveryArea>>>;
export type GetDeliveryAreaInfiniteQueryError = unknown;

export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌôúÎèô ÏßÄÏó≠ Ï°∞Ìöå
 */

export function useGetDeliveryAreaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDeliveryArea>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDeliveryAreaInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDeliveryAreaQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeliveryArea>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDeliveryAreaQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeliveryArea>>> = ({ signal }) => getDeliveryArea(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeliveryArea>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDeliveryAreaQueryResult = NonNullable<Awaited<ReturnType<typeof getDeliveryArea>>>;
export type GetDeliveryAreaQueryError = unknown;

export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeliveryArea>>,
          TError,
          Awaited<ReturnType<typeof getDeliveryArea>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌôúÎèô ÏßÄÏó≠ Ï°∞Ìöå
 */

export function useGetDeliveryArea<TData = Awaited<ReturnType<typeof getDeliveryArea>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDeliveryArea>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDeliveryAreaQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏùò ÌôúÎèô ÏßÄÏó≠ÏùÑ Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary ÌôúÎèô ÏßÄÏó≠ ÏàòÏ†ï
 */
export const updateDeliveryArea = (riderAreaUpdateRequest: RiderAreaUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/area`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderAreaUpdateRequest,
  });
};

export const getUpdateDeliveryAreaMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeliveryArea>>,
    TError,
    { data: RiderAreaUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeliveryArea>>,
  TError,
  { data: RiderAreaUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateDeliveryArea'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeliveryArea>>,
    { data: RiderAreaUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateDeliveryArea(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeliveryAreaMutationResult = NonNullable<Awaited<ReturnType<typeof updateDeliveryArea>>>;
export type UpdateDeliveryAreaMutationBody = RiderAreaUpdateRequest;
export type UpdateDeliveryAreaMutationError = unknown;

/**
 * @summary ÌôúÎèô ÏßÄÏó≠ ÏàòÏ†ï
 */
export const useUpdateDeliveryArea = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeliveryArea>>,
      TError,
      { data: RiderAreaUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeliveryArea>>,
  TError,
  { data: RiderAreaUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateDeliveryAreaMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏùÄÌñâÎ™Ö, Í≥ÑÏ¢åÎ≤àÌò∏, ÏòàÍ∏àÏ£ºÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ï†ïÏÇ∞ Í≥ÑÏ¢å Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateAccountInfo1 = (riderAccountInfoUpdateRequest: RiderAccountInfoUpdateRequest) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/account-info`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: riderAccountInfoUpdateRequest,
  });
};

export const getUpdateAccountInfo1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccountInfo1>>,
    TError,
    { data: RiderAccountInfoUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccountInfo1>>,
  TError,
  { data: RiderAccountInfoUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAccountInfo1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccountInfo1>>,
    { data: RiderAccountInfoUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccountInfo1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccountInfo1MutationResult = NonNullable<Awaited<ReturnType<typeof updateAccountInfo1>>>;
export type UpdateAccountInfo1MutationBody = RiderAccountInfoUpdateRequest;
export type UpdateAccountInfo1MutationError = unknown;

/**
 * @summary Ï†ïÏÇ∞ Í≥ÑÏ¢å Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateAccountInfo1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAccountInfo1>>,
      TError,
      { data: RiderAccountInfoUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAccountInfo1>>,
  TError,
  { data: RiderAccountInfoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAccountInfo1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÌôïÏù∏ÌïòÍ≥† ÏÉàÎ°úÏö¥ ÎπÑÎ∞ÄÎ≤àÌò∏Î°ú Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω
 */
export const changePassword = (changePasswordRequest: ChangePasswordRequest) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/users/me/password`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: changePasswordRequest,
  });
};

export const getChangePasswordMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changePassword>>,
    TError,
    { data: ChangePasswordRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof changePassword>>,
  TError,
  { data: ChangePasswordRequest },
  TContext
> => {
  const mutationKey = ['changePassword'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePassword>>, { data: ChangePasswordRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return changePassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof changePassword>>>;
export type ChangePasswordMutationBody = ChangePasswordRequest;
export type ChangePasswordMutationError = unknown;

/**
 * @summary ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω
 */
export const useChangePassword = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changePassword>>,
      TError,
      { data: ChangePasswordRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof changePassword>>, TError, { data: ChangePasswordRequest }, TContext> => {
  const mutationOptions = getChangePasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ ÌôúÏÑ±ÌôîÎêú Í≥†Í∞ù ÌîÑÎ°úÌïÑÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Í≥†Í∞ù ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */
export const getMyProfile2 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseCustomerProfileResponse>({
    url: `/api/v1/users/me/customer`,
    method: 'GET',
    signal,
  });
};

export const getGetMyProfile2InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/customer`] as const;
};

export const getGetMyProfile2QueryKey = () => {
  return [`/api/v1/users/me/customer`] as const;
};

export const getGetMyProfile2InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile2InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile2>>> = ({ signal }) => getMyProfile2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyProfile2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile2InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile2>>>;
export type GetMyProfile2InfiniteQueryError = unknown;

export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Í≥†Í∞ù ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */

export function useGetMyProfile2Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyProfile2>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile2InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyProfile2QueryOptions = <
  TData = Awaited<ReturnType<typeof getMyProfile2>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyProfile2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyProfile2>>> = ({ signal }) => getMyProfile2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyProfile2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyProfile2QueryResult = NonNullable<Awaited<ReturnType<typeof getMyProfile2>>>;
export type GetMyProfile2QueryError = unknown;

export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyProfile2>>,
          TError,
          Awaited<ReturnType<typeof getMyProfile2>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Í≥†Í∞ù ÌîÑÎ°úÌïÑ Ï°∞Ìöå
 */

export function useGetMyProfile2<TData = Awaited<ReturnType<typeof getMyProfile2>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyProfile2>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyProfile2QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í≥†Í∞ù ÌîÑÎ°úÌïÑÏùò ÎãâÎÑ§ÏûÑ, ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Í≥†Í∞ù ÌîÑÎ°úÌïÑ ÏàòÏ†ï
 */
export const updateMyProfile2 = (customerProfileUpdateRequest: CustomerProfileUpdateRequest) => {
  return customInstance<ApiResponseCustomerProfileResponse>({
    url: `/api/v1/users/me/customer`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: customerProfileUpdateRequest,
  });
};

export const getUpdateMyProfile2MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyProfile2>>,
    TError,
    { data: CustomerProfileUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMyProfile2>>,
  TError,
  { data: CustomerProfileUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateMyProfile2'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMyProfile2>>,
    { data: CustomerProfileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMyProfile2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyProfile2MutationResult = NonNullable<Awaited<ReturnType<typeof updateMyProfile2>>>;
export type UpdateMyProfile2MutationBody = CustomerProfileUpdateRequest;
export type UpdateMyProfile2MutationError = unknown;

/**
 * @summary ÎÇ¥ Í≥†Í∞ù ÌîÑÎ°úÌïÑ ÏàòÏ†ï
 */
export const useUpdateMyProfile2 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyProfile2>>,
      TError,
      { data: CustomerProfileUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMyProfile2>>,
  TError,
  { data: CustomerProfileUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateMyProfile2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞ÏÜ°ÏßÄ IDÎ°ú ÌäπÏ†ï Î∞∞ÏÜ°ÏßÄÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌäπÏ†ï Î∞∞ÏÜ°ÏßÄ Ï°∞Ìöå
 */
export const getAddress = (addressId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses/${addressId}`,
    method: 'GET',
    signal,
  });
};

export const getGetAddressInfiniteQueryKey = (addressId?: number) => {
  return ['infinate', `/api/v1/users/me/customer/addresses/${addressId}`] as const;
};

export const getGetAddressQueryKey = (addressId?: number) => {
  return [`/api/v1/users/me/customer/addresses/${addressId}`] as const;
};

export const getGetAddressInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>,
  TError = unknown,
>(
  addressId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAddressInfiniteQueryKey(addressId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAddress>>> = ({ signal }) => getAddress(addressId, signal);

  return { queryKey, queryFn, enabled: !!addressId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAddressInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAddress>>>;
export type GetAddressInfiniteQueryError = unknown;

export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌäπÏ†ï Î∞∞ÏÜ°ÏßÄ Ï°∞Ìöå
 */

export function useGetAddressInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAddress>>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAddressInfiniteQueryOptions(addressId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAddressQueryOptions = <TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAddressQueryKey(addressId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAddress>>> = ({ signal }) => getAddress(addressId, signal);

  return { queryKey, queryFn, enabled: !!addressId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getAddress>>>;
export type GetAddressQueryError = unknown;

export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAddress>>,
          TError,
          Awaited<ReturnType<typeof getAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌäπÏ†ï Î∞∞ÏÜ°ÏßÄ Ï°∞Ìöå
 */

export function useGetAddress<TData = Awaited<ReturnType<typeof getAddress>>, TError = unknown>(
  addressId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAddressQueryOptions(addressId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í∏∞Ï°¥ Î∞∞ÏÜ°ÏßÄÏùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Î∞∞ÏÜ°ÏßÄ ÏàòÏ†ï
 */
export const updateAddress = (addressId: number, addressUpdateRequest: AddressUpdateRequest) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses/${addressId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: addressUpdateRequest,
  });
};

export const getUpdateAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAddress>>,
    TError,
    { addressId: number; data: AddressUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAddress>>,
  TError,
  { addressId: number; data: AddressUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAddress>>,
    { addressId: number; data: AddressUpdateRequest }
  > = (props) => {
    const { addressId, data } = props ?? {};

    return updateAddress(addressId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAddressMutationResult = NonNullable<Awaited<ReturnType<typeof updateAddress>>>;
export type UpdateAddressMutationBody = AddressUpdateRequest;
export type UpdateAddressMutationError = unknown;

/**
 * @summary Î∞∞ÏÜ°ÏßÄ ÏàòÏ†ï
 */
export const useUpdateAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAddress>>,
      TError,
      { addressId: number; data: AddressUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAddress>>,
  TError,
  { addressId: number; data: AddressUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞ÏÜ°ÏßÄÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§. Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄÎäî ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§.
 * @summary Î∞∞ÏÜ°ÏßÄ ÏÇ≠Ï†ú
 */
export const deleteAddress = (addressId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/users/me/customer/addresses/${addressId}`, method: 'DELETE' });
};

export const getDeleteAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext> => {
  const mutationKey = ['deleteAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAddress>>, { addressId: number }> = (props) => {
    const { addressId } = props ?? {};

    return deleteAddress(addressId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAddressMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAddress>>>;

export type DeleteAddressMutationError = unknown;

/**
 * @summary Î∞∞ÏÜ°ÏßÄ ÏÇ≠Ï†ú
 */
export const useDeleteAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteAddress>>, TError, { addressId: number }, TContext> => {
  const mutationOptions = getDeleteAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï Î∞∞ÏÜ°ÏßÄÎ•º Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄÎ°ú ÏÑ§Ï†ïÌï©ÎãàÎã§.
 * @summary Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄ ÏÑ§Ï†ï
 */
export const setDefaultAddress = (addressId: number) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/users/me/customer/addresses/${addressId}/default`,
    method: 'PUT',
  });
};

export const getSetDefaultAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof setDefaultAddress>>, TError, { addressId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof setDefaultAddress>>, TError, { addressId: number }, TContext> => {
  const mutationKey = ['setDefaultAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof setDefaultAddress>>, { addressId: number }> = (
    props
  ) => {
    const { addressId } = props ?? {};

    return setDefaultAddress(addressId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetDefaultAddressMutationResult = NonNullable<Awaited<ReturnType<typeof setDefaultAddress>>>;

export type SetDefaultAddressMutationError = unknown;

/**
 * @summary Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄ ÏÑ§Ï†ï
 */
export const useSetDefaultAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setDefaultAddress>>,
      TError,
      { addressId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof setDefaultAddress>>, TError, { addressId: number }, TContext> => {
  const mutationOptions = getSetDefaultAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùò Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê Îã®Í±¥ Ï°∞Ìöå
 */
export const getStore = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseStoreResponse>({ url: `/api/v1/stores/${storeId}`, method: 'GET', signal });
};

export const getGetStoreInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}`] as const;
};

export const getGetStoreQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}`] as const;
};

export const getGetStoreInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStore>>> = ({ signal }) => getStore(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getStore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStore>>>;
export type GetStoreInfiniteQueryError = unknown;

export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetStoreInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getStore>>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetStoreQueryOptions = <TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStore>>> = ({ signal }) => getStore(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreQueryResult = NonNullable<Awaited<ReturnType<typeof getStore>>>;
export type GetStoreQueryError = unknown;

export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStore>>, TError, Awaited<ReturnType<typeof getStore>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Îã®Í±¥ Ï°∞Ìöå
 */

export function useGetStore<TData = Awaited<ReturnType<typeof getStore>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStore>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§, Î≥∏Ïù∏Ïùò ÏÉÅÏ†ê Ï†ïÎ≥¥Îßå ÏàòÏ†ïÏù¥ Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateStore = (storeId: number, storeUpdateRequest: StoreUpdateRequest) => {
  return customInstance<ApiResponseStoreResponse>({
    url: `/api/v1/stores/${storeId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: storeUpdateRequest,
  });
};

export const getUpdateStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStore>>,
    TError,
    { storeId: number; data: StoreUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStore>>,
  TError,
  { storeId: number; data: StoreUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStore>>,
    { storeId: number; data: StoreUpdateRequest }
  > = (props) => {
    const { storeId, data } = props ?? {};

    return updateStore(storeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStoreMutationResult = NonNullable<Awaited<ReturnType<typeof updateStore>>>;
export type UpdateStoreMutationBody = StoreUpdateRequest;
export type UpdateStoreMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateStore>>,
      TError,
      { storeId: number; data: StoreUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateStore>>,
  TError,
  { storeId: number; data: StoreUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§, Î≥∏Ïù∏Ïùò ÏÉÅÏ†êÎßå ÏÇ≠Ï†úÍ∞Ä Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê ÏÇ≠Ï†ú
 */
export const deleteStore = (storeId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/stores/${storeId}`, method: 'DELETE' });
};

export const getDeleteStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext> => {
  const mutationKey = ['deleteStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStore>>, { storeId: number }> = (props) => {
    const { storeId } = props ?? {};

    return deleteStore(storeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteStoreMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStore>>>;

export type DeleteStoreMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê ÏÇ≠Ï†ú
 */
export const useDeleteStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteStore>>, TError, { storeId: number }, TContext> => {
  const mutationOptions = getDeleteStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getProduct = (storeId: number, productId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseProductDetailResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}`,
    method: 'GET',
    signal,
  });
};

export const getGetProductInfiniteQueryKey = (storeId?: number, productId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/products/${productId}`] as const;
};

export const getGetProductQueryKey = (storeId?: number, productId?: number) => {
  return [`/api/v1/stores/${storeId}/products/${productId}`] as const;
};

export const getGetProductInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>,
  TError = unknown,
>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductInfiniteQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductInfiniteQueryError = unknown;

export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProduct>>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductInfiniteQueryOptions(storeId, productId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProductQueryOptions = <TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(storeId, productId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(storeId, productId, signal);

  return { queryKey, queryFn, enabled: !!(storeId && productId), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductQueryError = unknown;

export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  storeId: number,
  productId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductQueryOptions(storeId, productId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateProduct = (storeId: number, productId: number, productUpdateRequest: ProductUpdateRequest) => {
  return customInstance<ApiResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products/${productId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: productUpdateRequest,
  });
};

export const getUpdateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { storeId: number; productId: number; data: ProductUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { storeId: number; productId: number; data: ProductUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { storeId: number; productId: number; data: ProductUpdateRequest }
  > = (props) => {
    const { storeId, productId, data } = props ?? {};

    return updateProduct(storeId, productId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProductMutationResult = NonNullable<Awaited<ReturnType<typeof updateProduct>>>;
export type UpdateProductMutationBody = ProductUpdateRequest;
export type UpdateProductMutationError = unknown;

/**
 * @summary ÏÉÅÌíà Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { storeId: number; productId: number; data: ProductUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { storeId: number; productId: number; data: ProductUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÌíàÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà ÏÇ≠Ï†ú
 */
export const deleteProduct = (storeId: number, productId: number) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/stores/${storeId}/products/${productId}`, method: 'DELETE' });
};

export const getDeleteProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { storeId: number; productId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { storeId: number; productId: number },
  TContext
> => {
  const mutationKey = ['deleteProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { storeId: number; productId: number }
  > = (props) => {
    const { storeId, productId } = props ?? {};

    return deleteProduct(storeId, productId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>;

export type DeleteProductMutationError = unknown;

/**
 * @summary ÏÉÅÌíà ÏÇ≠Ï†ú
 */
export const useDeleteProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { storeId: number; productId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { storeId: number; productId: number },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Î≥¥ÎÇ∏ Ïù∏Ï¶ù ÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌïòÍ≥†, ÏÑ±Í≥µ Ïãú ÏÇ¨Ïö©Ïûê ÏóîÌã∞Ìã∞Ïùò `isEmailVerified` ÌïÑÎìúÎ•º `true`Î°ú ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§. **Ïù∏Ï¶ù ÎåÄÏÉÅ Ïù¥Î©îÏùºÏùÄ Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥Î°ú ÏÑúÎ≤ÑÏóêÏÑú Í∞ïÏ†ú Ï£ºÏûÖ**Îê©ÎãàÎã§.
 * @summary 2. Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìú Í≤ÄÏ¶ù
 */
export const verifyCode = (myEmailVerifyRequest: MyEmailVerifyRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/users/me/verify-email/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: myEmailVerifyRequest,
    signal,
  });
};

export const getVerifyCodeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyCode>>,
    TError,
    { data: MyEmailVerifyRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof verifyCode>>, TError, { data: MyEmailVerifyRequest }, TContext> => {
  const mutationKey = ['verifyCode'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCode>>, { data: MyEmailVerifyRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return verifyCode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyCodeMutationResult = NonNullable<Awaited<ReturnType<typeof verifyCode>>>;
export type VerifyCodeMutationBody = MyEmailVerifyRequest;
export type VerifyCodeMutationError = unknown;

/**
 * @summary 2. Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìú Í≤ÄÏ¶ù
 */
export const useVerifyCode = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyCode>>,
      TError,
      { data: MyEmailVerifyRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof verifyCode>>, TError, { data: MyEmailVerifyRequest }, TContext> => {
  const mutationOptions = getVerifyCodeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê(`rq.getActor()`)Ïùò Ïù¥Î©îÏùºÎ°ú Ïù∏Ï¶ù ÏΩîÎìúÎ•º Î∞úÏÜ°Ìï©ÎãàÎã§. **Ïù¥Î©îÏùº Ï£ºÏÜåÎäî ÏÑúÎ≤ÑÏóêÏÑú Í∞ïÏ†ú Ï£ºÏûÖ**ÎêòÎØÄÎ°ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏöîÏ≤≠ DTOÍ∞Ä ÌïÑÏöî ÏóÜÏäµÎãàÎã§.
 * @summary 1. Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°
 */
export const sendVerificationCodeForMyEmail = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/users/me/verify-email/send`, method: 'POST', signal });
};

export const getSendVerificationCodeForMyEmailMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext> => {
  const mutationKey = ['sendVerificationCodeForMyEmail'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, void> = () => {
    return sendVerificationCodeForMyEmail();
  };

  return { mutationFn, ...mutationOptions };
};

export type SendVerificationCodeForMyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>
>;

export type SendVerificationCodeForMyEmailMutationError = unknown;

/**
 * @summary 1. Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°
 */
export const useSendVerificationCodeForMyEmail = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof sendVerificationCodeForMyEmail>>, TError, void, TContext> => {
  const mutationOptions = getSendVerificationCodeForMyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞Îã¨ ÏÉÅÌÉúÎ•º ON ‚Üî OFFÎ°ú Ï†ÑÌôòÌï©ÎãàÎã§.
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú ÌÜ†Í∏Ä
 */
export const toggleDeliveryStatus = (signal?: AbortSignal) => {
  return customInstance<ApiResponseRiderProfileResponse>({
    url: `/api/v1/users/me/rider/toggle`,
    method: 'POST',
    signal,
  });
};

export const getToggleDeliveryStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext> => {
  const mutationKey = ['toggleDeliveryStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleDeliveryStatus>>, void> = () => {
    return toggleDeliveryStatus();
  };

  return { mutationFn, ...mutationOptions };
};

export type ToggleDeliveryStatusMutationResult = NonNullable<Awaited<ReturnType<typeof toggleDeliveryStatus>>>;

export type ToggleDeliveryStatusMutationError = unknown;

/**
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú ÌÜ†Í∏Ä
 */
export const useToggleDeliveryStatus = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof toggleDeliveryStatus>>, TError, void, TContext> => {
  const mutationOptions = getToggleDeliveryStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥¥Ïú†Ìïú Î™®Îì† ÌôúÏÑ± ÌîÑÎ°úÌïÑ Î™©Î°ùÍ≥º ÌòÑÏû¨ ÌôúÏÑ±ÌôîÎêú ÌîÑÎ°úÌïÑÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÌîÑÎ°úÌïÑ Î™©Î°ù Ï°∞Ìöå
 */
export const getAvailableProfiles = (signal?: AbortSignal) => {
  return customInstance<ApiResponseAvailableProfilesResponse>({
    url: `/api/v1/users/me/profiles`,
    method: 'GET',
    signal,
  });
};

export const getGetAvailableProfilesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/profiles`] as const;
};

export const getGetAvailableProfilesQueryKey = () => {
  return [`/api/v1/users/me/profiles`] as const;
};

export const getGetAvailableProfilesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAvailableProfilesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableProfiles>>> = ({ signal }) =>
    getAvailableProfiles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAvailableProfiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAvailableProfilesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableProfiles>>>;
export type GetAvailableProfilesInfiniteQueryError = unknown;

export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÌîÑÎ°úÌïÑ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAvailableProfilesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAvailableProfiles>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAvailableProfilesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAvailableProfilesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAvailableProfiles>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAvailableProfilesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableProfiles>>> = ({ signal }) =>
    getAvailableProfiles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAvailableProfiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAvailableProfilesQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableProfiles>>>;
export type GetAvailableProfilesQueryError = unknown;

export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableProfiles>>,
          TError,
          Awaited<ReturnType<typeof getAvailableProfiles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÌîÑÎ°úÌïÑ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAvailableProfiles<TData = Awaited<ReturnType<typeof getAvailableProfiles>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableProfiles>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAvailableProfilesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉàÎ°úÏö¥ ÌîÑÎ°úÌïÑÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§. Ï≤´ Î≤àÏß∏ ÌîÑÎ°úÌïÑÏù¥Îì† Ï∂îÍ∞Ä ÌîÑÎ°úÌïÑÏù¥Îì† ÎèôÏùºÌïòÍ≤å Ï≤òÎ¶¨Îê©ÎãàÎã§.
 * @summary ÌîÑÎ°úÌïÑ ÏÉùÏÑ±
 */
export const createProfile = (createProfileRequest: CreateProfileRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseCreateProfileResponse>({
    url: `/api/v1/users/me/profiles`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createProfileRequest,
    signal,
  });
};

export const getCreateProfileMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProfile>>,
    TError,
    { data: CreateProfileRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createProfile>>, TError, { data: CreateProfileRequest }, TContext> => {
  const mutationKey = ['createProfile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProfile>>, { data: CreateProfileRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProfileMutationResult = NonNullable<Awaited<ReturnType<typeof createProfile>>>;
export type CreateProfileMutationBody = CreateProfileRequest;
export type CreateProfileMutationError = unknown;

/**
 * @summary ÌîÑÎ°úÌïÑ ÏÉùÏÑ±
 */
export const useCreateProfile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProfile>>,
      TError,
      { data: CreateProfileRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createProfile>>, TError, { data: CreateProfileRequest }, TContext> => {
  const mutationOptions = getCreateProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥¥Ïú†Ìïú Îã§Î•∏ ÌîÑÎ°úÌïÑÎ°ú Ï†ÑÌôòÌï©ÎãàÎã§. ÌîÑÎ°úÌïÑ Ï†ÑÌôò Ïãú ÏÉàÎ°úÏö¥ Access TokenÏù¥ ÏûêÎèôÏúºÎ°ú Î∞úÍ∏âÎêòÎ©∞, ÌåêÎß§Ïûê ÌîÑÎ°úÌïÑÏù∏ Í≤ΩÏö∞ storeIdÏôÄ ÌîÑÎ°úÌïÑ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ÎèÑ Ìï®Íªò Î∞òÌôòÎê©ÎãàÎã§.
 * @summary ÌîÑÎ°úÌïÑ Ï†ÑÌôò
 */
export const switchProfile = (switchProfileRequest: SwitchProfileRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseSwitchProfileResponse>({
    url: `/api/v1/users/me/profile/switch`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: switchProfileRequest,
    signal,
  });
};

export const getSwitchProfileMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof switchProfile>>,
    TError,
    { data: SwitchProfileRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof switchProfile>>, TError, { data: SwitchProfileRequest }, TContext> => {
  const mutationKey = ['switchProfile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof switchProfile>>, { data: SwitchProfileRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return switchProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SwitchProfileMutationResult = NonNullable<Awaited<ReturnType<typeof switchProfile>>>;
export type SwitchProfileMutationBody = SwitchProfileRequest;
export type SwitchProfileMutationError = unknown;

/**
 * @summary ÌîÑÎ°úÌïÑ Ï†ÑÌôò
 */
export const useSwitchProfile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof switchProfile>>,
      TError,
      { data: SwitchProfileRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof switchProfile>>, TError, { data: SwitchProfileRequest }, TContext> => {
  const mutationOptions = getSwitchProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ Í≥†Í∞ù ÌîÑÎ°úÌïÑÏóê Îì±Î°ùÎêú Î™®Îì† Î∞∞ÏÜ°ÏßÄÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Î∞∞ÏÜ°ÏßÄ Î™©Î°ù Ï°∞Ìöå
 */
export const getMyAddresses = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListAddressResponse>({
    url: `/api/v1/users/me/customer/addresses`,
    method: 'GET',
    signal,
  });
};

export const getGetMyAddressesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/customer/addresses`] as const;
};

export const getGetMyAddressesQueryKey = () => {
  return [`/api/v1/users/me/customer/addresses`] as const;
};

export const getGetMyAddressesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyAddressesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyAddresses>>> = ({ signal }) => getMyAddresses(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyAddresses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyAddressesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyAddresses>>>;
export type GetMyAddressesInfiniteQueryError = unknown;

export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Î∞∞ÏÜ°ÏßÄ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetMyAddressesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyAddresses>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyAddressesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyAddressesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyAddresses>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyAddressesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyAddresses>>> = ({ signal }) => getMyAddresses(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyAddresses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyAddressesQueryResult = NonNullable<Awaited<ReturnType<typeof getMyAddresses>>>;
export type GetMyAddressesQueryError = unknown;

export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyAddresses>>,
          TError,
          Awaited<ReturnType<typeof getMyAddresses>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Î∞∞ÏÜ°ÏßÄ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetMyAddresses<TData = Awaited<ReturnType<typeof getMyAddresses>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyAddresses>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyAddressesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉàÎ°úÏö¥ Î∞∞ÏÜ°ÏßÄÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§. Ï≤´ Î≤àÏß∏ Î∞∞ÏÜ°ÏßÄÎäî ÏûêÎèôÏúºÎ°ú Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.
 * @summary Î∞∞ÏÜ°ÏßÄ Ï∂îÍ∞Ä
 */
export const addAddress = (addressCreateRequest: AddressCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: addressCreateRequest,
    signal,
  });
};

export const getAddAddressMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addAddress>>,
    TError,
    { data: AddressCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof addAddress>>, TError, { data: AddressCreateRequest }, TContext> => {
  const mutationKey = ['addAddress'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addAddress>>, { data: AddressCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return addAddress(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddAddressMutationResult = NonNullable<Awaited<ReturnType<typeof addAddress>>>;
export type AddAddressMutationBody = AddressCreateRequest;
export type AddAddressMutationError = unknown;

/**
 * @summary Î∞∞ÏÜ°ÏßÄ Ï∂îÍ∞Ä
 */
export const useAddAddress = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addAddress>>,
      TError,
      { data: AddressCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof addAddress>>, TError, { data: AddressCreateRequest }, TContext> => {
  const mutationOptions = getAddAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÉàÎ°úÏö¥ ÏÉÅÏ†êÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§, ÏÉÅÏ†êÏùÄ ÌïòÎÇòÏùò SellerProfile Îãπ 1Í∞ú ÏÉùÏÑ± Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê ÏÉùÏÑ±
 */
export const createStore = (storeCreateRequest: StoreCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseLong>({
    url: `/api/v1/stores`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: storeCreateRequest,
    signal,
  });
};

export const getCreateStoreMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createStore>>,
    TError,
    { data: StoreCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createStore>>, TError, { data: StoreCreateRequest }, TContext> => {
  const mutationKey = ['createStore'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStore>>, { data: StoreCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createStore(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateStoreMutationResult = NonNullable<Awaited<ReturnType<typeof createStore>>>;
export type CreateStoreMutationBody = StoreCreateRequest;
export type CreateStoreMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê ÏÉùÏÑ±
 */
export const useCreateStore = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createStore>>,
      TError,
      { data: StoreCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createStore>>, TError, { data: StoreCreateRequest }, TContext> => {
  const mutationOptions = getCreateStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÉÅÏ†êÏùò ÏòÅÏóÖ ÏÉÅÌÉú(OPEN/CLOSED)Î•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê ÏòÅÏóÖÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const toggleStoreStatus = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseStoreResponse>({
    url: `/api/v1/stores/${storeId}/toggle-status`,
    method: 'POST',
    signal,
  });
};

export const getToggleStoreStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext> => {
  const mutationKey = ['toggleStoreStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleStoreStatus>>, { storeId: number }> = (props) => {
    const { storeId } = props ?? {};

    return toggleStoreStatus(storeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToggleStoreStatusMutationResult = NonNullable<Awaited<ReturnType<typeof toggleStoreStatus>>>;

export type ToggleStoreStatusMutationError = unknown;

/**
 * @summary ÏÉÅÏ†ê ÏòÅÏóÖÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useToggleStoreStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof toggleStoreStatus>>, TError, { storeId: number }, TContext> => {
  const mutationOptions = getToggleStoreStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏÉÅÏ†êÏùò ÏÉÅÌíà Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÌíà Î™©Î°ù Ï°∞Ìöå
 */
export const searchProducts = (storeId: number, params: SearchProductsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSearchProductsInfiniteQueryKey = (storeId?: number, params?: SearchProductsParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/products`, ...(params ? [params] : [])] as const;
};

export const getSearchProductsQueryKey = (storeId?: number, params?: SearchProductsParams) => {
  return [`/api/v1/stores/${storeId}/products`, ...(params ? [params] : [])] as const;
};

export const getSearchProductsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({ signal }) =>
    searchProducts(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchProductsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchProducts>>>;
export type SearchProductsInfiniteQueryError = unknown;

export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà Î™©Î°ù Ï°∞Ìöå
 */

export function useSearchProductsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchProducts>>>,
  TError = unknown,
>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchProductsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchProductsQueryOptions = <TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({ signal }) =>
    searchProducts(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchProductsQueryResult = NonNullable<Awaited<ReturnType<typeof searchProducts>>>;
export type SearchProductsQueryError = unknown;

export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchProducts>>,
          TError,
          Awaited<ReturnType<typeof searchProducts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÌíà Î™©Î°ù Ï°∞Ìöå
 */

export function useSearchProducts<TData = Awaited<ReturnType<typeof searchProducts>>, TError = unknown>(
  storeId: number,
  params: SearchProductsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchProductsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉàÎ°úÏö¥ ÏÉÅÌíàÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary ÏÉÅÌíà ÏÉùÏÑ±
 */
export const createProduct = (storeId: number, productCreateRequest: ProductCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseProductResponse>({
    url: `/api/v1/stores/${storeId}/products`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: productCreateRequest,
    signal,
  });
};

export const getCreateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { storeId: number; data: ProductCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { storeId: number; data: ProductCreateRequest },
  TContext
> => {
  const mutationKey = ['createProduct'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { storeId: number; data: ProductCreateRequest }
  > = (props) => {
    const { storeId, data } = props ?? {};

    return createProduct(storeId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>;
export type CreateProductMutationBody = ProductCreateRequest;
export type CreateProductMutationError = unknown;

/**
 * @summary ÏÉÅÌíà ÏÉùÏÑ±
 */
export const useCreateProduct = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { storeId: number; data: ProductCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { storeId: number; data: ProductCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÉàÎ°úÏö¥ Î¶¨Î∑∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ ÏÉùÏÑ±
 */
export const createReview = (reviewCreateRequest: ReviewCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewCreateResponse>({
    url: `/api/v1/reviews`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: reviewCreateRequest,
    signal,
  });
};

export const getCreateReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createReview>>,
    TError,
    { data: ReviewCreateRequest },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError, { data: ReviewCreateRequest }, TContext> => {
  const mutationKey = ['createReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, { data: ReviewCreateRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return createReview(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>;
export type CreateReviewMutationBody = ReviewCreateRequest;
export type CreateReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ ÏÉùÏÑ±
 */
export const useCreateReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createReview>>,
      TError,
      { data: ReviewCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof createReview>>, TError, { data: ReviewCreateRequest }, TContext> => {
  const mutationOptions = getCreateReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÍ∞Ä ÌäπÏ†ï Î¶¨Î∑∞Ïóê Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ¶ÖÎãàÎã§. Ïù¥ÎØ∏ Ï¢ãÏïÑÏöîÌïú Î¶¨Î∑∞Îäî Ï§ëÎ≥µ Îì±Î°ùÌï† Ïàò ÏóÜÏäµÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const likeReview = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewLikeResponse>({
    url: `/api/v1/reviews/${reviewId}/like`,
    method: 'POST',
    signal,
  });
};

export const getLikeReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['likeReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof likeReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return likeReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof likeReview>>>;

export type LikeReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Îì±Î°ù
 */
export const useLikeReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof likeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getLikeReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÍ∞Ä ÌäπÏ†ï Î¶¨Î∑∞Ïóê Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ•∏ ÏÉÅÌÉúÏóêÏÑú Îã§Ïãú Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ•¥Î©¥ Ï∑®ÏÜåÎê©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const unLikeReview = (reviewId: number) => {
  return customInstance<ApiResponseReviewLikeResponse>({ url: `/api/v1/reviews/${reviewId}/like`, method: 'DELETE' });
};

export const getUnLikeReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['unLikeReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof unLikeReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return unLikeReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnLikeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof unLikeReview>>>;

export type UnLikeReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ï∑®ÏÜå
 */
export const useUnLikeReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof unLikeReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getUnLikeReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌäπÏ†ï ÏïåÎ¶ºÏùÑ ÏùΩÏùåÏúºÎ°ú ÌëúÏãúÌï©ÎãàÎã§.
 * @summary ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨
 */
export const markAsRead = (id: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/notifications/${id}/read`, method: 'POST', signal });
};

export const getMarkAsReadMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext> => {
  const mutationKey = ['markAsRead'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof markAsRead>>, { id: number }> = (props) => {
    const { id } = props ?? {};

    return markAsRead(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkAsReadMutationResult = NonNullable<Awaited<ReturnType<typeof markAsRead>>>;

export type MarkAsReadMutationError = unknown;

/**
 * @summary ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨
 */
export const useMarkAsRead = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof markAsRead>>, TError, { id: number }, TContext> => {
  const mutationOptions = getMarkAsReadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * S3Ïóê ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÍ∏∞ ÏúÑÌïú ÏûÑÏãú URL(Pre-signed URL)ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú Pre-signed URL ÏÉùÏÑ±
 */
export const generatePresignedUrl = (
  generatePresignedUrlRequest: GeneratePresignedUrlRequest,
  signal?: AbortSignal
) => {
  return customInstance<ApiResponseGeneratePresignedUrlResponse>({
    url: `/api/v1/media/presigned-url`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: generatePresignedUrlRequest,
    signal,
  });
};

export const getGeneratePresignedUrlMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generatePresignedUrl>>,
    TError,
    { data: GeneratePresignedUrlRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generatePresignedUrl>>,
  TError,
  { data: GeneratePresignedUrlRequest },
  TContext
> => {
  const mutationKey = ['generatePresignedUrl'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generatePresignedUrl>>,
    { data: GeneratePresignedUrlRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generatePresignedUrl(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GeneratePresignedUrlMutationResult = NonNullable<Awaited<ReturnType<typeof generatePresignedUrl>>>;
export type GeneratePresignedUrlMutationBody = GeneratePresignedUrlRequest;
export type GeneratePresignedUrlMutationError = unknown;

/**
 * @summary ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú Pre-signed URL ÏÉùÏÑ±
 */
export const useGeneratePresignedUrl = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generatePresignedUrl>>,
      TError,
      { data: GeneratePresignedUrlRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof generatePresignedUrl>>,
  TError,
  { data: GeneratePresignedUrlRequest },
  TContext
> => {
  const mutationOptions = getGeneratePresignedUrlMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎùºÏù¥ÎçîÍ∞Ä Î∞∞Îã¨ ÏöîÏ≤≠Ïóê ÎåÄÌï¥ ÏàòÎùΩ ÎòêÎäî Í±∞Ï†àÏùÑ Í≤∞Ï†ïÌï©ÎãàÎã§.
 * @summary ÎùºÏù¥Îçî Î∞∞Îã¨ ÏàòÎùΩ/Í±∞Ï†à Í≤∞Ï†ï
 */
export const decideOrderDelivery = (riderDecisionRequestDto: RiderDecisionRequestDto, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/decision`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: riderDecisionRequestDto,
    signal,
  });
};

export const getDecideOrderDeliveryMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof decideOrderDelivery>>,
    TError,
    { data: RiderDecisionRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof decideOrderDelivery>>,
  TError,
  { data: RiderDecisionRequestDto },
  TContext
> => {
  const mutationKey = ['decideOrderDelivery'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof decideOrderDelivery>>,
    { data: RiderDecisionRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return decideOrderDelivery(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DecideOrderDeliveryMutationResult = NonNullable<Awaited<ReturnType<typeof decideOrderDelivery>>>;
export type DecideOrderDeliveryMutationBody = RiderDecisionRequestDto;
export type DecideOrderDeliveryMutationError = unknown;

/**
 * @summary ÎùºÏù¥Îçî Î∞∞Îã¨ ÏàòÎùΩ/Í±∞Ï†à Í≤∞Ï†ï
 */
export const useDecideOrderDelivery = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof decideOrderDelivery>>,
      TError,
      { data: RiderDecisionRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof decideOrderDelivery>>,
  TError,
  { data: RiderDecisionRequestDto },
  TContext
> => {
  const mutationOptions = getDecideOrderDeliveryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞Îã¨ Í∞ÄÎä• ÏßÄÏó≠ÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§ (ÌòÑÏû¨Îäî 1Íµ∞Îç∞Îßå, ÏûêÏú†Î°úÏö¥ ÌòïÏãùÏúºÎ°ú Í∞ÄÎä•).
 * @summary Î∞∞Îã¨ Í∞ÄÎä• ÏßÄÏó≠ ÏÑ§Ï†ï
 */
export const updateDeliveryArea1 = (deliveryAreaRequestDto: DeliveryAreaRequestDto, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/area`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: deliveryAreaRequestDto,
    signal,
  });
};

export const getUpdateDeliveryArea1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDeliveryArea1>>,
    TError,
    { data: DeliveryAreaRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDeliveryArea1>>,
  TError,
  { data: DeliveryAreaRequestDto },
  TContext
> => {
  const mutationKey = ['updateDeliveryArea1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDeliveryArea1>>,
    { data: DeliveryAreaRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateDeliveryArea1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDeliveryArea1MutationResult = NonNullable<Awaited<ReturnType<typeof updateDeliveryArea1>>>;
export type UpdateDeliveryArea1MutationBody = DeliveryAreaRequestDto;
export type UpdateDeliveryArea1MutationError = unknown;

/**
 * @summary Î∞∞Îã¨ Í∞ÄÎä• ÏßÄÏó≠ ÏÑ§Ï†ï
 */
export const useUpdateDeliveryArea1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDeliveryArea1>>,
      TError,
      { data: DeliveryAreaRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateDeliveryArea1>>,
  TError,
  { data: DeliveryAreaRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateDeliveryArea1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÜåÎπÑÏûêÍ∞Ä Ï£ºÎ¨∏ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */
export const getAll = (params?: GetAllParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/customer/orders`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetAllInfiniteQueryKey = (params?: GetAllParams) => {
  return ['infinate', `/api/v1/customer/orders`, ...(params ? [params] : [])] as const;
};

export const getGetAllQueryKey = (params?: GetAllParams) => {
  return [`/api/v1/customer/orders`, ...(params ? [params] : [])] as const;
};

export const getGetAllInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
  TError = unknown,
>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllInfiniteQueryError = unknown;

export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params: undefined | GetAllParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllQueryOptions = <TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllQueryError = unknown;

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params: undefined | GetAllParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAll>>, TError, Awaited<ReturnType<typeof getAll>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = unknown>(
  params?: GetAllParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÜåÎπÑÏûêÍ∞Ä ÏÉÅÏ†êÏóê Ï£ºÎ¨∏ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÏÉùÏÑ±
 */
export const create = (orderCreateRequest: OrderCreateRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderCreateResponse>({
    url: `/api/v1/customer/orders`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderCreateRequest,
    signal,
  });
};

export const getCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext> => {
  const mutationKey = ['create'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof create>>, { data: OrderCreateRequest }> = (props) => {
    const { data } = props ?? {};

    return create(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMutationResult = NonNullable<Awaited<ReturnType<typeof create>>>;
export type CreateMutationBody = OrderCreateRequest;
export type CreateMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ ÏÉùÏÑ±
 */
export const useCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof create>>, TError, { data: OrderCreateRequest }, TContext> => {
  const mutationOptions = getCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÜåÎπÑÏûêÍ∞Ä ÏÉÅÏ†êÏóêÏÑú Ï£ºÎ¨∏ ÏàòÎùΩ Ï†ÑÏù∏ Ï£ºÎ¨∏ÏùÑ Ï∑®ÏÜåÌïòÎäî Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ Ï∑®ÏÜå
 */
export const cancel = (orderId: number, orderCancelRequest: OrderCancelRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/customer/orders/${orderId}/cancel`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderCancelRequest,
    signal,
  });
};

export const getCancelMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancel>>,
    TError,
    { orderId: number; data: OrderCancelRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancel>>,
  TError,
  { orderId: number; data: OrderCancelRequest },
  TContext
> => {
  const mutationKey = ['cancel'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancel>>,
    { orderId: number; data: OrderCancelRequest }
  > = (props) => {
    const { orderId, data } = props ?? {};

    return cancel(orderId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelMutationResult = NonNullable<Awaited<ReturnType<typeof cancel>>>;
export type CancelMutationBody = OrderCancelRequest;
export type CancelMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ Ï∑®ÏÜå
 */
export const useCancel = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancel>>,
      TError,
      { orderId: number; data: OrderCancelRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancel>>,
  TError,
  { orderId: number; data: OrderCancelRequest },
  TContext
> => {
  const mutationOptions = getCancelMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÜåÎπÑÏûêÍ∞Ä ÏÉùÏÑ±Ìïú Ï£ºÎ¨∏Ïùò Í≤∞Ï†ú ÏãúÎèÑ
 * @summary Ï£ºÎ¨∏ Í≤∞Ï†ú
 */
export const pay = (merchantUid: string, orderPayRequest: OrderPayRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/customer/orders/${merchantUid}/pay`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: orderPayRequest,
    signal,
  });
};

export const getPayMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pay>>,
    TError,
    { merchantUid: string; data: OrderPayRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pay>>,
  TError,
  { merchantUid: string; data: OrderPayRequest },
  TContext
> => {
  const mutationKey = ['pay'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pay>>,
    { merchantUid: string; data: OrderPayRequest }
  > = (props) => {
    const { merchantUid, data } = props ?? {};

    return pay(merchantUid, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PayMutationResult = NonNullable<Awaited<ReturnType<typeof pay>>>;
export type PayMutationBody = OrderPayRequest;
export type PayMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ Í≤∞Ï†ú
 */
export const usePay = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof pay>>,
      TError,
      { merchantUid: string; data: OrderPayRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof pay>>,
  TError,
  { merchantUid: string; data: OrderPayRequest },
  TContext
> => {
  const mutationOptions = getPayMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú Ïù∏Ï¶ù ÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌï©ÎãàÎã§. ÏÑ±Í≥µ Ïãú Ìï¥Îãπ Ïù∏Ï¶ù Ï†ïÎ≥¥Îäî RedisÏóêÏÑú ÏÇ≠Ï†úÎê©ÎãàÎã§.
 * @summary Ïù∏Ï¶ù ÏΩîÎìú Í≤ÄÏ¶ù
 */
export const verifyCode1 = (verificationVerifyRequest: VerificationVerifyRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/verification/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: verificationVerifyRequest,
    signal,
  });
};

export const getVerifyCode1MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyCode1>>,
    TError,
    { data: VerificationVerifyRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyCode1>>,
  TError,
  { data: VerificationVerifyRequest },
  TContext
> => {
  const mutationKey = ['verifyCode1'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCode1>>, { data: VerificationVerifyRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return verifyCode1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyCode1MutationResult = NonNullable<Awaited<ReturnType<typeof verifyCode1>>>;
export type VerifyCode1MutationBody = VerificationVerifyRequest;
export type VerifyCode1MutationError = unknown;

/**
 * @summary Ïù∏Ï¶ù ÏΩîÎìú Í≤ÄÏ¶ù
 */
export const useVerifyCode1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyCode1>>,
      TError,
      { data: VerificationVerifyRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof verifyCode1>>,
  TError,
  { data: VerificationVerifyRequest },
  TContext
> => {
  const mutationOptions = getVerifyCode1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Ïù¥Î©îÏùº ÎòêÎäî SMSÎ°ú Ïù∏Ï¶ù ÏΩîÎìúÎ•º Î∞úÏÜ°Ìï©ÎãàÎã§. (ÌòÑÏû¨Îäî Ïù¥Î©îÏùºÎßå ÏßÄÏõê). ÏöîÏ≤≠ Ïãú `purpose`Î•º Î™ÖÏãúÌï¥Ïïº Ìï©ÎãàÎã§.
 * @summary Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°
 */
export const sendVerificationCode = (verificationSendRequest: VerificationSendRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/verification/send`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: verificationSendRequest,
    signal,
  });
};

export const getSendVerificationCodeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendVerificationCode>>,
    TError,
    { data: VerificationSendRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendVerificationCode>>,
  TError,
  { data: VerificationSendRequest },
  TContext
> => {
  const mutationKey = ['sendVerificationCode'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendVerificationCode>>,
    { data: VerificationSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return sendVerificationCode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendVerificationCodeMutationResult = NonNullable<Awaited<ReturnType<typeof sendVerificationCode>>>;
export type SendVerificationCodeMutationBody = VerificationSendRequest;
export type SendVerificationCodeMutationError = unknown;

/**
 * @summary Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°
 */
export const useSendVerificationCode = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendVerificationCode>>,
      TError,
      { data: VerificationSendRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sendVerificationCode>>,
  TError,
  { data: VerificationSendRequest },
  TContext
> => {
  const mutationOptions = getSendVerificationCodeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Ïù¥Î©îÏùºÍ≥º ÎπÑÎ∞ÄÎ≤àÌò∏Î°ú Ïã†Í∑ú ÌöåÏõêÍ∞ÄÏûÖÏùÑ ÏßÑÌñâÌï©ÎãàÎã§. ÎπÑÎ∞ÄÎ≤àÌò∏Îäî 8Ïûê Ïù¥ÏÉÅ, ÏòÅÎ¨∏/Ïà´Ïûê/ÌäπÏàòÎ¨∏Ïûê Ìè¨Ìï®Ïù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.
 * @summary ÌöåÏõêÍ∞ÄÏûÖ
 */
export const signup = (signupRequest: SignupRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseSignupResponse>({
    url: `/api/v1/auth/signup`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: signupRequest,
    signal,
  });
};

export const getSignupMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext> => {
  const mutationKey = ['signup'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signup>>, { data: SignupRequest }> = (props) => {
    const { data } = props ?? {};

    return signup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignupMutationResult = NonNullable<Awaited<ReturnType<typeof signup>>>;
export type SignupMutationBody = SignupRequest;
export type SignupMutationError = unknown;

/**
 * @summary ÌöåÏõêÍ∞ÄÏûÖ
 */
export const useSignup = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof signup>>, TError, { data: SignupRequest }, TContext> => {
  const mutationOptions = getSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * HttpOnly Ïø†ÌÇ§Ïóê Ï†ÄÏû•Îêú Refresh TokenÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ ÏÉàÎ°úÏö¥ Access TokenÏùÑ Î∞úÍ∏âÎ∞õÏäµÎãàÎã§.
 * @summary ÌÜ†ÌÅ∞ Ïû¨Î∞úÍ∏â
 */
export const refreshToken = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/auth/refresh`, method: 'POST', signal });
};

export const getRefreshTokenMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext> => {
  const mutationKey = ['refreshToken'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, void> = () => {
    return refreshToken();
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>;

export type RefreshTokenMutationError = unknown;

/**
 * @summary ÌÜ†ÌÅ∞ Ïû¨Î∞úÍ∏â
 */
export const useRefreshToken = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof refreshToken>>, TError, void, TContext> => {
  const mutationOptions = getRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Ïù∏Ï¶ù ÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌïòÍ≥† ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ïÏö© `resetToken`ÏùÑ Î∞úÍ∏âÎ∞õÏäµÎãàÎã§.
 * @summary 2Îã®Í≥Ñ: Ïù∏Ï¶ù ÏΩîÎìú Í≤ÄÏ¶ù Î∞è Ïû¨ÏÑ§Ï†ï ÌÜ†ÌÅ∞ Î∞úÍ∏â
 */
export const verifyCode2 = (passwordResetVerifyRequest: PasswordResetVerifyRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponsePasswordResetVerifyResponse>({
    url: `/api/v1/auth/password/reset/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: passwordResetVerifyRequest,
    signal,
  });
};

export const getVerifyCode2MutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyCode2>>,
    TError,
    { data: PasswordResetVerifyRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyCode2>>,
  TError,
  { data: PasswordResetVerifyRequest },
  TContext
> => {
  const mutationKey = ['verifyCode2'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCode2>>, { data: PasswordResetVerifyRequest }> = (
    props
  ) => {
    const { data } = props ?? {};

    return verifyCode2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyCode2MutationResult = NonNullable<Awaited<ReturnType<typeof verifyCode2>>>;
export type VerifyCode2MutationBody = PasswordResetVerifyRequest;
export type VerifyCode2MutationError = unknown;

/**
 * @summary 2Îã®Í≥Ñ: Ïù∏Ï¶ù ÏΩîÎìú Í≤ÄÏ¶ù Î∞è Ïû¨ÏÑ§Ï†ï ÌÜ†ÌÅ∞ Î∞úÍ∏â
 */
export const useVerifyCode2 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyCode2>>,
      TError,
      { data: PasswordResetVerifyRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof verifyCode2>>,
  TError,
  { data: PasswordResetVerifyRequest },
  TContext
> => {
  const mutationOptions = getVerifyCode2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÏÇ¨Ïö©Ïûê Ïù¥Î©îÏùºÎ°ú ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ïÏö© Ïù∏Ï¶ù ÏΩîÎìúÎ•º Î∞úÏÜ°Ìï©ÎãàÎã§. (VerificationPurpose.PASSWORD_RESET ÏÇ¨Ïö©)
 * @summary 1Îã®Í≥Ñ: ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ï ÏöîÏ≤≠ (Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°)
 */
export const requestPasswordReset = (passwordResetRequest: PasswordResetRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/password/reset/request`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: passwordResetRequest,
    signal,
  });
};

export const getRequestPasswordResetMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    TError,
    { data: PasswordResetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: PasswordResetRequest },
  TContext
> => {
  const mutationKey = ['requestPasswordReset'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestPasswordReset>>,
    { data: PasswordResetRequest }
  > = (props) => {
    const { data } = props ?? {};

    return requestPasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestPasswordResetMutationResult = NonNullable<Awaited<ReturnType<typeof requestPasswordReset>>>;
export type RequestPasswordResetMutationBody = PasswordResetRequest;
export type RequestPasswordResetMutationError = unknown;

/**
 * @summary 1Îã®Í≥Ñ: ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ï ÏöîÏ≤≠ (Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°)
 */
export const useRequestPasswordReset = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestPasswordReset>>,
      TError,
      { data: PasswordResetRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestPasswordReset>>,
  TError,
  { data: PasswordResetRequest },
  TContext
> => {
  const mutationOptions = getRequestPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞úÍ∏âÎ∞õÏùÄ `resetToken`Í≥º ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÏµúÏ¢ÖÏ†ÅÏúºÎ°ú ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§. ÌÜ†ÌÅ∞ÏùÄ ÏÇ¨Ïö© Ï¶âÏãú Î¨¥Ìö®ÌôîÎê©ÎãàÎã§.
 * @summary 3Îã®Í≥Ñ: ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏ ÏÑ§Ï†ï
 */
export const confirmPasswordReset = (
  passwordResetConfirmRequest: PasswordResetConfirmRequest,
  signal?: AbortSignal
) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/auth/password/reset/confirm`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: passwordResetConfirmRequest,
    signal,
  });
};

export const getConfirmPasswordResetMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    TError,
    { data: PasswordResetConfirmRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: PasswordResetConfirmRequest },
  TContext
> => {
  const mutationKey = ['confirmPasswordReset'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    { data: PasswordResetConfirmRequest }
  > = (props) => {
    const { data } = props ?? {};

    return confirmPasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmPasswordResetMutationResult = NonNullable<Awaited<ReturnType<typeof confirmPasswordReset>>>;
export type ConfirmPasswordResetMutationBody = PasswordResetConfirmRequest;
export type ConfirmPasswordResetMutationError = unknown;

/**
 * @summary 3Îã®Í≥Ñ: ÏÉà ÎπÑÎ∞ÄÎ≤àÌò∏ ÏÑ§Ï†ï
 */
export const useConfirmPasswordReset = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmPasswordReset>>,
      TError,
      { data: PasswordResetConfirmRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: PasswordResetConfirmRequest },
  TContext
> => {
  const mutationOptions = getConfirmPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const logout = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/auth/logout`, method: 'POST', signal });
};

export const getLogoutMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationKey = ['logout'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
    return logout();
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError = unknown;

export const useLogout = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const logoutAll = (signal?: AbortSignal) => {
  return customInstance<ApiResponseVoid>({ url: `/api/v1/auth/logout/all`, method: 'POST', signal });
};

export const getLogoutAllMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext> => {
  const mutationKey = ['logoutAll'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutAll>>, void> = () => {
    return logoutAll();
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutAllMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAll>>>;

export type LogoutAllMutationError = unknown;

export const useLogoutAll = <TError = unknown, TContext = unknown>(
  options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext> },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof logoutAll>>, TError, void, TContext> => {
  const mutationOptions = getLogoutAllMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Ïù¥Î©îÏùºÍ≥º ÎπÑÎ∞ÄÎ≤àÌò∏Î°ú Î°úÍ∑∏Ïù∏Ìï©ÎãàÎã§. Access TokenÍ≥º Refresh TokenÏù¥ Î∞úÍ∏âÎê©ÎãàÎã§. X-Device-ID Ìó§ÎçîÍ∞Ä ÏóÜÏùÑ Í≤ΩÏö∞, ÏÑúÎ≤ÑÏóêÏÑú ÏÉùÏÑ±ÌïòÏó¨ ÏùëÎãµ Ìó§ÎçîÎ°ú Î∞òÌôòÌï©ÎãàÎã§.
 * @summary Î°úÍ∑∏Ïù∏
 */
export const login = (loginRequest: LoginRequest, signal?: AbortSignal) => {
  return customInstance<ApiResponseLoginResponse>({
    url: `/api/v1/auth/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: loginRequest,
    signal,
  });
};

export const getLoginMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext> => {
  const mutationKey = ['login'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginRequest }> = (props) => {
    const { data } = props ?? {};

    return login(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = LoginRequest;
export type LoginMutationError = unknown;

/**
 * @summary Î°úÍ∑∏Ïù∏
 */
export const useLogin = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof login>>, TError, { data: LoginRequest }, TContext> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ÏùÑ Í±∞Ï†àÌïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ Í±∞Ï†à
 */
export const rejectOrder = (storeId: number, orderId: number) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/stores/${storeId}/orders/${orderId}/reject`,
    method: 'PATCH',
  });
};

export const getRejectOrderMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectOrder>>,
    TError,
    { storeId: number; orderId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationKey = ['rejectOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectOrder>>, { storeId: number; orderId: number }> = (
    props
  ) => {
    const { storeId, orderId } = props ?? {};

    return rejectOrder(storeId, orderId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RejectOrderMutationResult = NonNullable<Awaited<ReturnType<typeof rejectOrder>>>;

export type RejectOrderMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ Í±∞Ï†à
 */
export const useRejectOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectOrder>>,
      TError,
      { storeId: number; orderId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rejectOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationOptions = getRejectOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ÏùÑ ÏàòÎùΩÌïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ
 */
export const acceptOrder = (storeId: number, orderId: number) => {
  return customInstance<ApiResponseString>({
    url: `/api/v1/stores/${storeId}/orders/${orderId}/accept`,
    method: 'PATCH',
  });
};

export const getAcceptOrderMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptOrder>>,
    TError,
    { storeId: number; orderId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof acceptOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationKey = ['acceptOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof acceptOrder>>, { storeId: number; orderId: number }> = (
    props
  ) => {
    const { storeId, orderId } = props ?? {};

    return acceptOrder(storeId, orderId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AcceptOrderMutationResult = NonNullable<Awaited<ReturnType<typeof acceptOrder>>>;

export type AcceptOrderMutationError = unknown;

/**
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ
 */
export const useAcceptOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof acceptOrder>>,
      TError,
      { storeId: number; orderId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof acceptOrder>>,
  TError,
  { storeId: number; orderId: number },
  TContext
> => {
  const mutationOptions = getAcceptOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î¶¨Î∑∞ idÎ°ú Î¶¨Î∑∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï°∞Ìöå
 */
export const getReview = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewResponse>({ url: `/api/v1/reviews/${reviewId}`, method: 'GET', signal });
};

export const getGetReviewInfiniteQueryKey = (reviewId?: number) => {
  return ['infinate', `/api/v1/reviews/${reviewId}`] as const;
};

export const getGetReviewQueryKey = (reviewId?: number) => {
  return [`/api/v1/reviews/${reviewId}`] as const;
};

export const getGetReviewInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewInfiniteQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReview>>> = ({ signal }) => getReview(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReview>>>;
export type GetReviewInfiniteQueryError = unknown;

export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReview>>, TError, Awaited<ReturnType<typeof getReview>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReview>>,
          TError,
          Awaited<ReturnType<typeof getReview>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï°∞Ìöå
 */

export function useGetReviewInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getReview>>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewInfiniteQueryOptions(reviewId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetReviewQueryOptions = <TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReview>>> = ({ signal }) => getReview(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewQueryResult = NonNullable<Awaited<ReturnType<typeof getReview>>>;
export type GetReviewQueryError = unknown;

export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReview>>, TError, Awaited<ReturnType<typeof getReview>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReview>>,
          TError,
          Awaited<ReturnType<typeof getReview>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï°∞Ìöå
 */

export function useGetReview<TData = Awaited<ReturnType<typeof getReview>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReview>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewQueryOptions(reviewId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î¶¨Î∑∞Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ ÏÇ≠Ï†ú
 */
export const deleteReview = (reviewId: number) => {
  return customInstance<ApiResponseString>({ url: `/api/v1/reviews/${reviewId}`, method: 'DELETE' });
};

export const getDeleteReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext> => {
  const mutationKey = ['deleteReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReview>>, { reviewId: number }> = (props) => {
    const { reviewId } = props ?? {};

    return deleteReview(reviewId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteReviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReview>>>;

export type DeleteReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ ÏÇ≠Ï†ú
 */
export const useDeleteReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteReview>>, TError, { reviewId: number }, TContext> => {
  const mutationOptions = getDeleteReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î¶¨Î∑∞Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ ÏàòÏ†ï
 */
export const updateReview = (reviewId: number, reviewUpdateRequest: ReviewUpdateRequest) => {
  return customInstance<ApiResponseReviewResponse>({
    url: `/api/v1/reviews/${reviewId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: reviewUpdateRequest,
  });
};

export const getUpdateReviewMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateReview>>,
    TError,
    { reviewId: number; data: ReviewUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateReview>>,
  TError,
  { reviewId: number; data: ReviewUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateReview'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateReview>>,
    { reviewId: number; data: ReviewUpdateRequest }
  > = (props) => {
    const { reviewId, data } = props ?? {};

    return updateReview(reviewId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof updateReview>>>;
export type UpdateReviewMutationBody = ReviewUpdateRequest;
export type UpdateReviewMutationError = unknown;

/**
 * @summary Î¶¨Î∑∞ ÏàòÏ†ï
 */
export const useUpdateReview = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateReview>>,
      TError,
      { reviewId: number; data: ReviewUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateReview>>,
  TError,
  { reviewId: number; data: ReviewUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateReviewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î∞∞Îã¨ IDÏôÄ Îã§Ïùå ÏÉÅÌÉúÎ•º Î∞õÏïÑ Î∞∞Îã¨ ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const updateStatus = (deliveryId: number, params: UpdateStatusParams) => {
  return customInstance<void>({ url: `/api/v1/deliveries/${deliveryId}/delivery-status`, method: 'PATCH', params });
};

export const getUpdateStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateStatus>>,
    TError,
    { deliveryId: number; params: UpdateStatusParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateStatus>>,
  TError,
  { deliveryId: number; params: UpdateStatusParams },
  TContext
> => {
  const mutationKey = ['updateStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStatus>>,
    { deliveryId: number; params: UpdateStatusParams }
  > = (props) => {
    const { deliveryId, params } = props ?? {};

    return updateStatus(deliveryId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateStatus>>>;

export type UpdateStatusMutationError = unknown;

/**
 * @summary Î∞∞Îã¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useUpdateStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateStatus>>,
      TError,
      { deliveryId: number; params: UpdateStatusParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateStatus>>,
  TError,
  { deliveryId: number; params: UpdateStatusParams },
  TContext
> => {
  const mutationOptions = getUpdateStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎùºÏù¥Îçî ÌÜ†Í∏Ä Ï†ÑÌôòÏúºÎ°ú ÏÉÅÌÉúÎ•º Ï†ÑÌôòÌï©ÎãàÎã§.
 * @summary ÎùºÏù¥Îçî ÌÜ†Í∏Ä Ï†ÑÌôò
 */
export const updateRiderStatus = (riderToggleStatusRequestDto: RiderToggleStatusRequestDto) => {
  return customInstance<ApiResponseVoid>({
    url: `/api/v1/deliveries/status`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: riderToggleStatusRequestDto,
  });
};

export const getUpdateRiderStatusMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRiderStatus>>,
    TError,
    { data: RiderToggleStatusRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRiderStatus>>,
  TError,
  { data: RiderToggleStatusRequestDto },
  TContext
> => {
  const mutationKey = ['updateRiderStatus'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRiderStatus>>,
    { data: RiderToggleStatusRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateRiderStatus(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRiderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof updateRiderStatus>>>;
export type UpdateRiderStatusMutationBody = RiderToggleStatusRequestDto;
export type UpdateRiderStatusMutationError = unknown;

/**
 * @summary ÎùºÏù¥Îçî ÌÜ†Í∏Ä Ï†ÑÌôò
 */
export const useUpdateRiderStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRiderStatus>>,
      TError,
      { data: RiderToggleStatusRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateRiderStatus>>,
  TError,
  { data: RiderToggleStatusRequestDto },
  TContext
> => {
  const mutationOptions = getUpdateRiderStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÌòÑÏû¨ Î∞∞Îã¨ Í∞ÄÎä•Ìïú ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏Ìï©ÎãàÎã§. (ÌîÑÎ°úÌïÑ ÌôúÏÑ±Ìôî + Î∞∞Îã¨ ÏÉÅÌÉú ON)
 * @summary Î∞∞Îã¨ Í∞ÄÎä• Ïó¨Î∂Ä Ï°∞Ìöå
 */
export const checkAvailability = (signal?: AbortSignal) => {
  return customInstance<ApiResponseBoolean>({ url: `/api/v1/users/me/rider/available`, method: 'GET', signal });
};

export const getCheckAvailabilityInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/rider/available`] as const;
};

export const getCheckAvailabilityQueryKey = () => {
  return [`/api/v1/users/me/rider/available`] as const;
};

export const getCheckAvailabilityInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckAvailabilityInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkAvailability>>> = ({ signal }) =>
    checkAvailability(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof checkAvailability>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CheckAvailabilityInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof checkAvailability>>>;
export type CheckAvailabilityInfiniteQueryError = unknown;

export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î∞∞Îã¨ Í∞ÄÎä• Ïó¨Î∂Ä Ï°∞Ìöå
 */

export function useCheckAvailabilityInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof checkAvailability>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCheckAvailabilityInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCheckAvailabilityQueryOptions = <
  TData = Awaited<ReturnType<typeof checkAvailability>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckAvailabilityQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkAvailability>>> = ({ signal }) =>
    checkAvailability(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof checkAvailability>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CheckAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof checkAvailability>>>;
export type CheckAvailabilityQueryError = unknown;

export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAvailability>>,
          TError,
          Awaited<ReturnType<typeof checkAvailability>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î∞∞Îã¨ Í∞ÄÎä• Ïó¨Î∂Ä Ï°∞Ìöå
 */

export function useCheckAvailability<TData = Awaited<ReturnType<typeof checkAvailability>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkAvailability>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCheckAvailabilityQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌòÑÏû¨ ÏÑ§Ï†ïÎêú Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄ Ï°∞Ìöå
 */
export const getDefaultAddress = (signal?: AbortSignal) => {
  return customInstance<ApiResponseAddressResponse>({
    url: `/api/v1/users/me/customer/addresses/default`,
    method: 'GET',
    signal,
  });
};

export const getGetDefaultAddressInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/users/me/customer/addresses/default`] as const;
};

export const getGetDefaultAddressQueryKey = () => {
  return [`/api/v1/users/me/customer/addresses/default`] as const;
};

export const getGetDefaultAddressInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultAddressInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultAddress>>> = ({ signal }) =>
    getDefaultAddress(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDefaultAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDefaultAddressInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultAddress>>>;
export type GetDefaultAddressInfiniteQueryError = unknown;

export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄ Ï°∞Ìöå
 */

export function useGetDefaultAddressInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDefaultAddress>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDefaultAddressInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDefaultAddressQueryOptions = <
  TData = Awaited<ReturnType<typeof getDefaultAddress>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDefaultAddressQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDefaultAddress>>> = ({ signal }) =>
    getDefaultAddress(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDefaultAddress>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDefaultAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getDefaultAddress>>>;
export type GetDefaultAddressQueryError = unknown;

export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDefaultAddress>>,
          TError,
          Awaited<ReturnType<typeof getDefaultAddress>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Í∏∞Î≥∏ Î∞∞ÏÜ°ÏßÄ Ï°∞Ìöå
 */

export function useGetDefaultAddress<TData = Awaited<ReturnType<typeof getDefaultAddress>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDefaultAddress>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDefaultAddressQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * sort, cursor, size Î•º Î∞õÏïÑ ÌäπÏ†ï ÏÉÅÏ†êÏùò Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ Î∞è ÌèâÍ∑† ÌèâÏ†êÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌäπÏ†ï ÏÉÅÏ†ê Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ & ÌèâÏ†ê Ï°∞Ìöå
 */
export const getStoreReviews = (storeId: number, params: GetStoreReviewsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewRatingAndListResponseDto>({
    url: `/api/v1/stores/${storeId}/reviews`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetStoreReviewsInfiniteQueryKey = (storeId?: number, params?: GetStoreReviewsParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetStoreReviewsQueryKey = (storeId?: number, params?: GetStoreReviewsParams) => {
  return [`/api/v1/stores/${storeId}/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetStoreReviewsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreReviewsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreReviews>>> = ({ signal }) =>
    getStoreReviews(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getStoreReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreReviews>>>;
export type GetStoreReviewsInfiniteQueryError = unknown;

export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌäπÏ†ï ÏÉÅÏ†ê Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ & ÌèâÏ†ê Ï°∞Ìöå
 */

export function useGetStoreReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getStoreReviews>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreReviewsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetStoreReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoreReviewsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoreReviews>>> = ({ signal }) =>
    getStoreReviews(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStoreReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStoreReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getStoreReviews>>>;
export type GetStoreReviewsQueryError = unknown;

export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStoreReviews>>,
          TError,
          Awaited<ReturnType<typeof getStoreReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÌäπÏ†ï ÏÉÅÏ†ê Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ & ÌèâÏ†ê Ï°∞Ìöå
 */

export function useGetStoreReviews<TData = Awaited<ReturnType<typeof getStoreReviews>>, TError = unknown>(
  storeId: number,
  params: GetStoreReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoreReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStoreReviewsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ùÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
 */
export const getPendingOrders = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/pending`,
    method: 'GET',
    signal,
  });
};

export const getGetPendingOrdersInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/pending`] as const;
};

export const getGetPendingOrdersQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}/orders/pending`] as const;
};

export const getGetPendingOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingOrdersInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingOrders>>> = ({ signal }) =>
    getPendingOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPendingOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingOrders>>>;
export type GetPendingOrdersInfiniteQueryError = unknown;

export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPendingOrdersInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPendingOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPendingOrdersQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingOrders>>> = ({ signal }) =>
    getPendingOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPendingOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingOrders>>>;
export type GetPendingOrdersQueryError = unknown;

export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingOrders>>,
          TError,
          Awaited<ReturnType<typeof getPendingOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÏàòÎùΩ ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPendingOrders<TData = Awaited<ReturnType<typeof getPendingOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPendingOrdersQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌåêÎß§ÏûêÍ∞Ä Ï£ºÎ¨∏ Ïù¥Î†•ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */
export const getOrdersHistory = (storeId: number, params?: GetOrdersHistoryParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/history`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetOrdersHistoryInfiniteQueryKey = (storeId?: number, params?: GetOrdersHistoryParams) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/history`, ...(params ? [params] : [])] as const;
};

export const getGetOrdersHistoryQueryKey = (storeId?: number, params?: GetOrdersHistoryParams) => {
  return [`/api/v1/stores/${storeId}/orders/history`, ...(params ? [params] : [])] as const;
};

export const getGetOrdersHistoryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrdersHistoryInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersHistory>>> = ({ signal }) =>
    getOrdersHistory(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getOrdersHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrdersHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersHistory>>>;
export type GetOrdersHistoryInfiniteQueryError = unknown;

export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params: undefined | GetOrdersHistoryParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetOrdersHistoryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getOrdersHistory>>>,
  TError = unknown,
>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetOrdersHistoryInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetOrdersHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrdersHistoryQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersHistory>>> = ({ signal }) =>
    getOrdersHistory(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrdersHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrdersHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersHistory>>>;
export type GetOrdersHistoryQueryError = unknown;

export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params: undefined | GetOrdersHistoryParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrdersHistory>>,
          TError,
          Awaited<ReturnType<typeof getOrdersHistory>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetOrdersHistory<TData = Awaited<ReturnType<typeof getOrdersHistory>>, TError = unknown>(
  storeId: number,
  params?: GetOrdersHistoryParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersHistory>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetOrdersHistoryQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌåêÎß§ÏûêÍ∞Ä ÏÉÅÏ†êÏùò Ï£ºÎ¨∏ Ï≤òÎ¶¨ Ï§ëÏù∏ Î™©Î°ùÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ ÌòÑÌô© Î™©Î°ù Ï°∞Ìöå
 */
export const getAcceptedOrders = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/stores/${storeId}/orders/accepted`,
    method: 'GET',
    signal,
  });
};

export const getGetAcceptedOrdersInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/stores/${storeId}/orders/accepted`] as const;
};

export const getGetAcceptedOrdersQueryKey = (storeId?: number) => {
  return [`/api/v1/stores/${storeId}/orders/accepted`] as const;
};

export const getGetAcceptedOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAcceptedOrdersInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcceptedOrders>>> = ({ signal }) =>
    getAcceptedOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAcceptedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAcceptedOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAcceptedOrders>>>;
export type GetAcceptedOrdersInfiniteQueryError = unknown;

export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÌòÑÌô© Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAcceptedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAcceptedOrders>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcceptedOrdersInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAcceptedOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAcceptedOrders>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAcceptedOrdersQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcceptedOrders>>> = ({ signal }) =>
    getAcceptedOrders(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAcceptedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAcceptedOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getAcceptedOrders>>>;
export type GetAcceptedOrdersQueryError = unknown;

export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcceptedOrders>>,
          TError,
          Awaited<ReturnType<typeof getAcceptedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ ÌòÑÌô© Î™©Î°ù Ï°∞Ìöå
 */

export function useGetAcceptedOrders<TData = Awaited<ReturnType<typeof getAcceptedOrders>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcceptedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAcceptedOrdersQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ Ï£ºÍ∞ÑÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */
export const getWeekSettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/week`,
    method: 'GET',
    signal,
  });
};

export const getGetWeekSettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/week`] as const;
};

export const getGetWeekSettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/week`] as const;
};

export const getGetWeekSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements>>> = ({ signal }) =>
    getWeekSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements>>>;
export type GetWeekSettlementsInfiniteQueryError = unknown;

export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetWeekSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getWeekSettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements>>> = ({ signal }) =>
    getWeekSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements>>>;
export type GetWeekSettlementsQueryError = unknown;

export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlements<TData = Awaited<ReturnType<typeof getWeekSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ ÌäπÏ†ï Í∏∞Í∞ÑÏùò Ï†ïÏÇ∞ Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */
export const getPeriodSettlements = (storeId: number, params: GetPeriodSettlementsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/period`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetPeriodSettlementsInfiniteQueryKey = (storeId?: number, params?: GetPeriodSettlementsParams) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlementsQueryKey = (storeId?: number, params?: GetPeriodSettlementsParams) => {
  return [`/api/v1/store/settlements/${storeId}/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlementsInfiniteQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements>>> = ({ signal }) =>
    getPeriodSettlements(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements>>>;
export type GetPeriodSettlementsInfiniteQueryError = unknown;

export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlementsInfiniteQueryOptions(storeId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPeriodSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPeriodSettlements>>,
  TError = unknown,
>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlementsQueryKey(storeId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements>>> = ({ signal }) =>
    getPeriodSettlements(storeId, params, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements>>>;
export type GetPeriodSettlementsQueryError = unknown;

export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlements<TData = Awaited<ReturnType<typeof getPeriodSettlements>>, TError = unknown>(
  storeId: number,
  params: GetPeriodSettlementsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlementsQueryOptions(storeId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ ÏõîÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */
export const getMonthSettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/month`,
    method: 'GET',
    signal,
  });
};

export const getGetMonthSettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/month`] as const;
};

export const getGetMonthSettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/month`] as const;
};

export const getGetMonthSettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements>>> = ({ signal }) =>
    getMonthSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements>>>;
export type GetMonthSettlementsInfiniteQueryError = unknown;

export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMonthSettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMonthSettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements>>> = ({ signal }) =>
    getMonthSettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements>>>;
export type GetMonthSettlementsQueryError = unknown;

export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlements<TData = Awaited<ReturnType<typeof getMonthSettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†êÏù¥ ÏùºÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */
export const getDaySettlements = (storeId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/store/settlements/${storeId}/day`,
    method: 'GET',
    signal,
  });
};

export const getGetDaySettlementsInfiniteQueryKey = (storeId?: number) => {
  return ['infinate', `/api/v1/store/settlements/${storeId}/day`] as const;
};

export const getGetDaySettlementsQueryKey = (storeId?: number) => {
  return [`/api/v1/store/settlements/${storeId}/day`] as const;
};

export const getGetDaySettlementsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlementsInfiniteQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements>>> = ({ signal }) =>
    getDaySettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements>>>;
export type GetDaySettlementsInfiniteQueryError = unknown;

export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlementsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements>>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlementsInfiniteQueryOptions(storeId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDaySettlementsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDaySettlements>>,
  TError = unknown,
>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlementsQueryKey(storeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements>>> = ({ signal }) =>
    getDaySettlements(storeId, signal);

  return { queryKey, queryFn, enabled: !!storeId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements>>>;
export type GetDaySettlementsQueryError = unknown;

export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlements<TData = Awaited<ReturnType<typeof getDaySettlements>>, TError = unknown>(
  storeId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlementsQueryOptions(storeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î™®Îì† ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */
export const getCategories = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListStoreCategoryResponse>({
    url: `/api/v1/store-categories`,
    method: 'GET',
    signal,
  });
};

export const getGetCategoriesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/store-categories`] as const;
};

export const getGetCategoriesQueryKey = () => {
  return [`/api/v1/store-categories`] as const;
};

export const getGetCategoriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesInfiniteQueryError = unknown;

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesQueryError = unknown;

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏ†ê Í≤ÄÏÉâ Í≤∞Í≥ºÎ•º Ïª§ÏÑú Í∏∞Î∞ò ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖòÏúºÎ°ú Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÉÅÏ†ê Í≤ÄÏÉâ
 */
export const searchStores = (params: SearchStoresParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseStoreSearchResponse>({
    url: `/api/v1/search/stores`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSearchStoresInfiniteQueryKey = (params?: SearchStoresParams) => {
  return ['infinate', `/api/v1/search/stores`, ...(params ? [params] : [])] as const;
};

export const getSearchStoresQueryKey = (params?: SearchStoresParams) => {
  return [`/api/v1/search/stores`, ...(params ? [params] : [])] as const;
};

export const getSearchStoresInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStoresInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStores>>> = ({ signal }) => searchStores(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchStores>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchStoresInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchStores>>>;
export type SearchStoresInfiniteQueryError = unknown;

export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Í≤ÄÏÉâ
 */

export function useSearchStoresInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchStores>>>,
  TError = unknown,
>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchStoresInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchStoresQueryOptions = <TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStoresQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStores>>> = ({ signal }) => searchStores(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchStores>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchStoresQueryResult = NonNullable<Awaited<ReturnType<typeof searchStores>>>;
export type SearchStoresQueryError = unknown;

export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchStores>>,
          TError,
          Awaited<ReturnType<typeof searchStores>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏÉÅÏ†ê Í≤ÄÏÉâ
 */

export function useSearchStores<TData = Awaited<ReturnType<typeof searchStores>>, TError = unknown>(
  params: SearchStoresParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStores>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchStoresQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ Ï£ºÍ∞ÑÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */
export const getWeekSettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/week`,
    method: 'GET',
    signal,
  });
};

export const getGetWeekSettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/week`] as const;
};

export const getGetWeekSettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/week`] as const;
};

export const getGetWeekSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements1>>> = ({ signal }) =>
    getWeekSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements1>>>;
export type GetWeekSettlements1InfiniteQueryError = unknown;

export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getWeekSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetWeekSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getWeekSettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWeekSettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSettlements1>>> = ({ signal }) =>
    getWeekSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSettlements1>>>;
export type GetWeekSettlements1QueryError = unknown;

export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getWeekSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Ï£ºÍ∞ÑÎ≥Ñ Ï°∞Ìöå
 */

export function useGetWeekSettlements1<TData = Awaited<ReturnType<typeof getWeekSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekSettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ Ï†ïÏÇ∞ ÏöîÏïΩ Ïπ¥Îìú Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏöîÏïΩ Ï°∞Ìöå
 */
export const getSummary = (signal?: AbortSignal) => {
  return customInstance<ApiResponseSummaryResponse>({
    url: `/api/v1/rider/settlements/summary`,
    method: 'GET',
    signal,
  });
};

export const getGetSummaryInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/summary`] as const;
};

export const getGetSummaryQueryKey = () => {
  return [`/api/v1/rider/settlements/summary`] as const;
};

export const getGetSummaryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSummaryInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSummary>>> = ({ signal }) => getSummary(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSummaryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSummary>>>;
export type GetSummaryInfiniteQueryError = unknown;

export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏöîÏïΩ Ï°∞Ìöå
 */

export function useGetSummaryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSummary>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSummaryInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSummaryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSummary>>> = ({ signal }) => getSummary(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getSummary>>>;
export type GetSummaryQueryError = unknown;

export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSummary>>,
          TError,
          Awaited<ReturnType<typeof getSummary>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏöîÏïΩ Ï°∞Ìöå
 */

export function useGetSummary<TData = Awaited<ReturnType<typeof getSummary>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSummary>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSummaryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ ÌäπÏ†ï Í∏∞Í∞ÑÏùò Ï†ïÏÇ∞ Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */
export const getPeriodSettlements1 = (params: GetPeriodSettlements1Params, signal?: AbortSignal) => {
  return customInstance<ApiResponseSettlementResponse>({
    url: `/api/v1/rider/settlements/period`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetPeriodSettlements1InfiniteQueryKey = (params?: GetPeriodSettlements1Params) => {
  return ['infinate', `/api/v1/rider/settlements/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlements1QueryKey = (params?: GetPeriodSettlements1Params) => {
  return [`/api/v1/rider/settlements/period`, ...(params ? [params] : [])] as const;
};

export const getGetPeriodSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlements1InfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements1>>> = ({ signal }) =>
    getPeriodSettlements1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements1>>>;
export type GetPeriodSettlements1InfiniteQueryError = unknown;

export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPeriodSettlements1>>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlements1InfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPeriodSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getPeriodSettlements1>>,
  TError = unknown,
>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPeriodSettlements1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeriodSettlements1>>> = ({ signal }) =>
    getPeriodSettlements1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPeriodSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPeriodSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getPeriodSettlements1>>>;
export type GetPeriodSettlements1QueryError = unknown;

export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeriodSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getPeriodSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ Í∏∞Í∞Ñ Ï°∞Ìöå
 */

export function useGetPeriodSettlements1<TData = Awaited<ReturnType<typeof getPeriodSettlements1>>, TError = unknown>(
  params: GetPeriodSettlements1Params,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeriodSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPeriodSettlements1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ ÏõîÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */
export const getMonthSettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/month`,
    method: 'GET',
    signal,
  });
};

export const getGetMonthSettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/month`] as const;
};

export const getGetMonthSettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/month`] as const;
};

export const getGetMonthSettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements1>>> = ({ signal }) =>
    getMonthSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements1>>>;
export type GetMonthSettlements1InfiniteQueryError = unknown;

export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMonthSettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMonthSettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getMonthSettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonthSettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthSettlements1>>> = ({ signal }) =>
    getMonthSettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonthSettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonthSettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getMonthSettlements1>>>;
export type GetMonthSettlements1QueryError = unknown;

export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthSettlements1>>,
          TError,
          Awaited<ReturnType<typeof getMonthSettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏõîÎ≥Ñ Ï°∞Ìöå
 */

export function useGetMonthSettlements1<TData = Awaited<ReturnType<typeof getMonthSettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthSettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonthSettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Î∞∞Îã¨ÏõêÏù¥ ÏùºÎ≥Ñ Ï†ïÏÇ∞ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */
export const getDaySettlements1 = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListSettlementResponse>({
    url: `/api/v1/rider/settlements/day`,
    method: 'GET',
    signal,
  });
};

export const getGetDaySettlements1InfiniteQueryKey = () => {
  return ['infinate', `/api/v1/rider/settlements/day`] as const;
};

export const getGetDaySettlements1QueryKey = () => {
  return [`/api/v1/rider/settlements/day`] as const;
};

export const getGetDaySettlements1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlements1InfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements1>>> = ({ signal }) =>
    getDaySettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlements1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements1>>>;
export type GetDaySettlements1InfiniteQueryError = unknown;

export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlements1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDaySettlements1>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlements1InfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDaySettlements1QueryOptions = <
  TData = Awaited<ReturnType<typeof getDaySettlements1>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDaySettlements1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaySettlements1>>> = ({ signal }) =>
    getDaySettlements1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDaySettlements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaySettlements1QueryResult = NonNullable<Awaited<ReturnType<typeof getDaySettlements1>>>;
export type GetDaySettlements1QueryError = unknown;

export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDaySettlements1>>,
          TError,
          Awaited<ReturnType<typeof getDaySettlements1>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï†ïÏÇ∞ ÏùºÎ≥Ñ Ï°∞Ìöå
 */

export function useGetDaySettlements1<TData = Awaited<ReturnType<typeof getDaySettlements1>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaySettlements1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDaySettlements1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÍ∞Ä Ïñ¥Îñ§ Ï£ºÎ¨∏Ïùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */
export const get = (orderId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({ url: `/api/v1/rider/orders/${orderId}`, method: 'GET', signal });
};

export const getGetInfiniteQueryKey = (orderId?: number) => {
  return ['infinate', `/api/v1/rider/orders/${orderId}`] as const;
};

export const getGetQueryKey = (orderId?: number) => {
  return [`/api/v1/rider/orders/${orderId}`] as const;
};

export const getGetInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInfiniteQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetInfiniteQueryError = unknown;

export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */

export function useGetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof get>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInfiniteQueryOptions(orderId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetQueryError = unknown;

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetQueryOptions(orderId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌäπÏ†ï Î¶¨Î∑∞Ïóê Îã¨Î¶∞ Ï¢ãÏïÑÏöîÏùò ÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ïàò Ï°∞Ìöå
 */
export const getReviewLikeCount = (reviewId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewLikeResponse>({
    url: `/api/v1/reviews/${reviewId}/likes`,
    method: 'GET',
    signal,
  });
};

export const getGetReviewLikeCountInfiniteQueryKey = (reviewId?: number) => {
  return ['infinate', `/api/v1/reviews/${reviewId}/likes`] as const;
};

export const getGetReviewLikeCountQueryKey = (reviewId?: number) => {
  return [`/api/v1/reviews/${reviewId}/likes`] as const;
};

export const getGetReviewLikeCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewLikeCountInfiniteQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewLikeCount>>> = ({ signal }) =>
    getReviewLikeCount(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReviewLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewLikeCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewLikeCount>>>;
export type GetReviewLikeCountInfiniteQueryError = unknown;

export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ïàò Ï°∞Ìöå
 */

export function useGetReviewLikeCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReviewLikeCount>>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewLikeCountInfiniteQueryOptions(reviewId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetReviewLikeCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getReviewLikeCount>>,
  TError = unknown,
>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReviewLikeCountQueryKey(reviewId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewLikeCount>>> = ({ signal }) =>
    getReviewLikeCount(reviewId, signal);

  return { queryKey, queryFn, enabled: !!reviewId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReviewLikeCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReviewLikeCountQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewLikeCount>>>;
export type GetReviewLikeCountQueryError = unknown;

export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewLikeCount>>,
          TError,
          Awaited<ReturnType<typeof getReviewLikeCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î¶¨Î∑∞ Ï¢ãÏïÑÏöî Ïàò Ï°∞Ìöå
 */

export function useGetReviewLikeCount<TData = Awaited<ReturnType<typeof getReviewLikeCount>>, TError = unknown>(
  reviewId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewLikeCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetReviewLikeCountQueryOptions(reviewId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÏïåÎ¶º Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. isRead ÌååÎùºÎØ∏ÌÑ∞Î°ú ÏùΩÏùå/ÏïàÏùΩÏùå ÌïÑÌÑ∞ÎßÅÏù¥ Í∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏïåÎ¶º Î™©Î°ù Ï°∞Ìöå
 */
export const getNotifications = (params?: GetNotificationsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseListNotification>({ url: `/api/v1/notifications`, method: 'GET', params, signal });
};

export const getGetNotificationsInfiniteQueryKey = (params?: GetNotificationsParams) => {
  return ['infinate', `/api/v1/notifications`, ...(params ? [params] : [])] as const;
};

export const getGetNotificationsQueryKey = (params?: GetNotificationsParams) => {
  return [`/api/v1/notifications`, ...(params ? [params] : [])] as const;
};

export const getGetNotificationsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) =>
    getNotifications(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>;
export type GetNotificationsInfiniteQueryError = unknown;

export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params: undefined | GetNotificationsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏïåÎ¶º Î™©Î°ù Ï°∞Ìöå
 */

export function useGetNotificationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNotifications>>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetNotificationsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNotificationsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) =>
    getNotifications(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>;
export type GetNotificationsQueryError = unknown;

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params: undefined | GetNotificationsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏïåÎ¶º Î™©Î°ù Ï°∞Ìöå
 */

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = unknown>(
  params?: GetNotificationsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetNotificationsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º ÏàòÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º Ïàò Ï°∞Ìöå
 */
export const getUnreadCount = (signal?: AbortSignal) => {
  return customInstance<ApiResponseLong>({ url: `/api/v1/notifications/unread-count`, method: 'GET', signal });
};

export const getGetUnreadCountInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/notifications/unread-count`] as const;
};

export const getGetUnreadCountQueryKey = () => {
  return [`/api/v1/notifications/unread-count`] as const;
};

export const getGetUnreadCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCount>>> = ({ signal }) => getUnreadCount(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCount>>>;
export type GetUnreadCountInfiniteQueryError = unknown;

export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º Ïàò Ï°∞Ìöå
 */

export function useGetUnreadCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUnreadCount>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUnreadCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getUnreadCount>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCount>>> = ({ signal }) => getUnreadCount(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCount>>>;
export type GetUnreadCountQueryError = unknown;

export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏùΩÏßÄ ÏïäÏùÄ ÏïåÎ¶º Ïàò Ï°∞Ìöå
 */

export function useGetUnreadCount<TData = Awaited<ReturnType<typeof getUnreadCount>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCount>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * SSEÎ•º ÌÜµÌï¥ Ïã§ÏãúÍ∞Ñ ÏïåÎ¶ºÏùÑ Íµ¨ÎèÖÌï©ÎãàÎã§. Í∞Å Í∏∞Í∏∞Î≥ÑÎ°ú Í≥†Ïú†Ìïú deviceIdÎ•º Ìó§Îçî(X-Device-ID)Ïóê Îã¥ÏïÑ ÏöîÏ≤≠Ìï¥Ïïº Ìï©ÎãàÎã§.
 * @summary SSE Íµ¨ÎèÖ
 */
export const subscribe = (signal?: AbortSignal) => {
  return customInstance<SseEmitter>({ url: `/api/v1/notifications/stream`, method: 'GET', signal });
};

export const getSubscribeInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/notifications/stream`] as const;
};

export const getSubscribeQueryKey = () => {
  return [`/api/v1/notifications/stream`] as const;
};

export const getSubscribeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSubscribeInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof subscribe>>> = ({ signal }) => subscribe(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof subscribe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SubscribeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof subscribe>>>;
export type SubscribeInfiniteQueryError = unknown;

export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof subscribe>>, TError, Awaited<ReturnType<typeof subscribe>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscribe>>,
          TError,
          Awaited<ReturnType<typeof subscribe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary SSE Íµ¨ÎèÖ
 */

export function useSubscribeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof subscribe>>>, TError = unknown>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSubscribeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSubscribeQueryOptions = <TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSubscribeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof subscribe>>> = ({ signal }) => subscribe(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof subscribe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SubscribeQueryResult = NonNullable<Awaited<ReturnType<typeof subscribe>>>;
export type SubscribeQueryError = unknown;

export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof subscribe>>, TError, Awaited<ReturnType<typeof subscribe>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscribe>>,
          TError,
          Awaited<ReturnType<typeof subscribe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary SSE Íµ¨ÎèÖ
 */

export function useSubscribe<TData = Awaited<ReturnType<typeof subscribe>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof subscribe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSubscribeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * sort, cursor, sizeÏôÄ ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑÏóê Îî∞Îùº ÏûëÏÑ±Ìïú Î¶¨Î∑∞ or ÎÇ¥Í≤å Îã¨Î¶∞ Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ Î∞è ÌèâÍ∑† ÌèâÏ†êÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ & ÌèâÏ†ê Ï°∞Ìöå
 */
export const getMyReviews = (params: GetMyReviewsParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseReviewRatingAndListResponseDto>({
    url: `/api/v1/me/reviews`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetMyReviewsInfiniteQueryKey = (params?: GetMyReviewsParams) => {
  return ['infinate', `/api/v1/me/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetMyReviewsQueryKey = (params?: GetMyReviewsParams) => {
  return [`/api/v1/me/reviews`, ...(params ? [params] : [])] as const;
};

export const getGetMyReviewsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyReviewsInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyReviews>>> = ({ signal }) => getMyReviews(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyReviewsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyReviews>>>;
export type GetMyReviewsInfiniteQueryError = unknown;

export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ & ÌèâÏ†ê Ï°∞Ìöå
 */

export function useGetMyReviewsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMyReviews>>>,
  TError = unknown,
>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyReviewsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMyReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyReviewsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyReviews>>> = ({ signal }) => getMyReviews(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyReviews>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyReviews>>>;
export type GetMyReviewsQueryError = unknown;

export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyReviews>>,
          TError,
          Awaited<ReturnType<typeof getMyReviews>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÎÇ¥ Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ & ÌèâÏ†ê Ï°∞Ìöå
 */

export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  params: GetMyReviewsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMyReviewsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩÍ≥º Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§. cursor Í∏∞Î∞ò ÌéòÏù¥ÏßïÏùÑ ÏßÄÏõêÌï©ÎãàÎã§. filter: LATEST(ÏµúÏã†Ïàú), OLDEST(Ïò§ÎûòÎêúÏàú)
 * @summary Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩ Ï°∞Ìöå + Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getTotalDeliveries = (params?: GetTotalDeliveriesParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseDeliveredSummaryResponseDto>({
    url: `/api/v1/deliveries/total`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetTotalDeliveriesInfiniteQueryKey = (params?: GetTotalDeliveriesParams) => {
  return ['infinate', `/api/v1/deliveries/total`, ...(params ? [params] : [])] as const;
};

export const getGetTotalDeliveriesQueryKey = (params?: GetTotalDeliveriesParams) => {
  return [`/api/v1/deliveries/total`, ...(params ? [params] : [])] as const;
};

export const getGetTotalDeliveriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalDeliveriesInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTotalDeliveries>>> = ({ signal }) =>
    getTotalDeliveries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTotalDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTotalDeliveries>>>;
export type GetTotalDeliveriesInfiniteQueryError = unknown;

export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params: undefined | GetTotalDeliveriesParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩ Ï°∞Ìöå + Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetTotalDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTotalDeliveries>>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTotalDeliveriesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTotalDeliveriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTotalDeliveries>>,
  TError = unknown,
>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalDeliveriesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTotalDeliveries>>> = ({ signal }) =>
    getTotalDeliveries(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTotalDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getTotalDeliveries>>>;
export type GetTotalDeliveriesQueryError = unknown;

export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params: undefined | GetTotalDeliveriesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTotalDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï¥ù Î∞∞Îã¨ ÎÇ¥Ïó≠ ÏöîÏïΩ Ï°∞Ìöå + Î∞∞Îã¨ ÏôÑÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetTotalDeliveries<TData = Awaited<ReturnType<typeof getTotalDeliveries>>, TError = unknown>(
  params?: GetTotalDeliveriesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotalDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTotalDeliveriesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò Ïò§Îäò Î∞∞Îã¨ ÎÇ¥Ïó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïò§ÎäòÏùò Î∞∞Îã¨ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */
export const getTodayDeliveries = (signal?: AbortSignal) => {
  return customInstance<ApiResponseTodayDeliveringResponseDto>({
    url: `/api/v1/deliveries/today`,
    method: 'GET',
    signal,
  });
};

export const getGetTodayDeliveriesInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/deliveries/today`] as const;
};

export const getGetTodayDeliveriesQueryKey = () => {
  return [`/api/v1/deliveries/today`] as const;
};

export const getGetTodayDeliveriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTodayDeliveriesInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodayDeliveries>>> = ({ signal }) =>
    getTodayDeliveries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTodayDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTodayDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTodayDeliveries>>>;
export type GetTodayDeliveriesInfiniteQueryError = unknown;

export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ïò§ÎäòÏùò Î∞∞Îã¨ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetTodayDeliveriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTodayDeliveries>>>,
  TError = unknown,
>(
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTodayDeliveriesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTodayDeliveriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTodayDeliveries>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTodayDeliveriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodayDeliveries>>> = ({ signal }) =>
    getTodayDeliveries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTodayDeliveries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTodayDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getTodayDeliveries>>>;
export type GetTodayDeliveriesQueryError = unknown;

export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getTodayDeliveries>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ïò§ÎäòÏùò Î∞∞Îã¨ ÎÇ¥Ïó≠ Ï°∞Ìöå
 */

export function useGetTodayDeliveries<TData = Awaited<ReturnType<typeof getTodayDeliveries>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayDeliveries>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTodayDeliveriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ ÎÇ¥Ïó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. (ÎèôÏ†Å riderProfile ID ÌïÑÏöîÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∏°ÏóêÏÑú 1Î∂ÑÏóê Ìïú Î≤àÏî© Ìè¥ÎßÅ Í∂åÏû•)
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Ï°∞Ìöå
 */
export const getInProgressDelivery = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListCurrentDeliveringResponseDto>({
    url: `/api/v1/deliveries/in-progress`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressDeliveryInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/deliveries/in-progress`] as const;
};

export const getGetInProgressDeliveryQueryKey = () => {
  return [`/api/v1/deliveries/in-progress`] as const;
};

export const getGetInProgressDeliveryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDeliveryInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDelivery>>> = ({ signal }) =>
    getInProgressDelivery(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDeliveryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressDelivery>>>;
export type GetInProgressDeliveryInfiniteQueryError = unknown;

export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Ï°∞Ìöå
 */

export function useGetInProgressDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDelivery>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDeliveryInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressDeliveryQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressDelivery>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDeliveryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDelivery>>> = ({ signal }) =>
    getInProgressDelivery(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDeliveryQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressDelivery>>>;
export type GetInProgressDeliveryQueryError = unknown;

export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Ï°∞Ìöå
 */

export function useGetInProgressDelivery<TData = Awaited<ReturnType<typeof getInProgressDelivery>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDelivery>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDeliveryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎùºÏù¥ÎçîÏùò ÏßÑÌñâ Ï§ëÏù∏ Îã®Ïùº Î∞∞Îã¨ ÎÇ¥Ïó≠ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. (ÎèôÏ†Å riderProfile ID ÌïÑÏöîÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∏°ÏóêÏÑú 1Î∂ÑÏóê Ìïú Î≤àÏî© Ìè¥ÎßÅ Í∂åÏû•)
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Îã®Í±¥ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getInProgressDetailDelivery = (deliveryId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseCurrentDeliveringDetailsDto>({
    url: `/api/v1/deliveries/in-progress/${deliveryId}`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressDetailDeliveryInfiniteQueryKey = (deliveryId?: number) => {
  return ['infinate', `/api/v1/deliveries/in-progress/${deliveryId}`] as const;
};

export const getGetInProgressDetailDeliveryQueryKey = (deliveryId?: number) => {
  return [`/api/v1/deliveries/in-progress/${deliveryId}`] as const;
};

export const getGetInProgressDetailDeliveryInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDetailDeliveryInfiniteQueryKey(deliveryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDetailDelivery>>> = ({ signal }) =>
    getInProgressDetailDelivery(deliveryId, signal);

  return { queryKey, queryFn, enabled: !!deliveryId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDetailDeliveryInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInProgressDetailDelivery>>
>;
export type GetInProgressDetailDeliveryInfiniteQueryError = unknown;

export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Îã®Í±¥ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetInProgressDetailDeliveryInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressDetailDelivery>>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDetailDeliveryInfiniteQueryOptions(deliveryId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressDetailDeliveryQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressDetailDeliveryQueryKey(deliveryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressDetailDelivery>>> = ({ signal }) =>
    getInProgressDetailDelivery(deliveryId, signal);

  return { queryKey, queryFn, enabled: !!deliveryId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressDetailDeliveryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInProgressDetailDelivery>>
>;
export type GetInProgressDetailDeliveryQueryError = unknown;

export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
          TError,
          Awaited<ReturnType<typeof getInProgressDetailDelivery>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâ Ï§ëÏù∏ Î∞∞Îã¨ Îã®Í±¥ ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetInProgressDetailDelivery<
  TData = Awaited<ReturnType<typeof getInProgressDetailDelivery>>,
  TError = unknown,
>(
  deliveryId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressDetailDelivery>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressDetailDeliveryQueryOptions(deliveryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÜåÎπÑÏûêÍ∞Ä Ïñ¥Îñ§ Ï£ºÎ¨∏Ïùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */
export const get1 = (orderId: number, signal?: AbortSignal) => {
  return customInstance<ApiResponseOrderResponse>({ url: `/api/v1/customer/orders/${orderId}`, method: 'GET', signal });
};

export const getGet1InfiniteQueryKey = (orderId?: number) => {
  return ['infinate', `/api/v1/customer/orders/${orderId}`] as const;
};

export const getGet1QueryKey = (orderId?: number) => {
  return [`/api/v1/customer/orders/${orderId}`] as const;
};

export const getGet1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGet1InfiniteQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get1>>> = ({ signal }) => get1(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof get1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Get1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof get1>>>;
export type Get1InfiniteQueryError = unknown;

export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */

export function useGet1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof get1>>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGet1InfiniteQueryOptions(orderId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGet1QueryOptions = <TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGet1QueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get1>>> = ({ signal }) => get1(orderId, signal);

  return { queryKey, queryFn, enabled: !!orderId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Get1QueryResult = NonNullable<Awaited<ReturnType<typeof get1>>>;
export type Get1QueryError = unknown;

export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof get1>>, TError, Awaited<ReturnType<typeof get1>>>,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Ï£ºÎ¨∏ Îã®Ïùº Ï°∞Ìöå
 */

export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
  orderId: number,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGet1QueryOptions(orderId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÜåÎπÑÏûêÍ∞Ä ÏßÑÌñâÏ§ëÏù∏ Ï£ºÎ¨∏ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary ÏßÑÌñâÏ§ëÏù∏ Ï£ºÎ¨∏ Ï°∞Ìöå
 */
export const getInProgressOrders = (signal?: AbortSignal) => {
  return customInstance<ApiResponseListOrderResponse>({
    url: `/api/v1/customer/orders/in-progress`,
    method: 'GET',
    signal,
  });
};

export const getGetInProgressOrdersInfiniteQueryKey = () => {
  return ['infinate', `/api/v1/customer/orders/in-progress`] as const;
};

export const getGetInProgressOrdersQueryKey = () => {
  return [`/api/v1/customer/orders/in-progress`] as const;
};

export const getGetInProgressOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressOrdersInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressOrders>>> = ({ signal }) =>
    getInProgressOrders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getInProgressOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressOrders>>>;
export type GetInProgressOrdersInfiniteQueryError = unknown;

export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâÏ§ëÏù∏ Ï£ºÎ¨∏ Ï°∞Ìöå
 */

export function useGetInProgressOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getInProgressOrders>>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressOrdersInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetInProgressOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof getInProgressOrders>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInProgressOrdersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressOrders>>> = ({ signal }) =>
    getInProgressOrders(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInProgressOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInProgressOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressOrders>>>;
export type GetInProgressOrdersQueryError = unknown;

export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressOrders>>,
          TError,
          Awaited<ReturnType<typeof getInProgressOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary ÏßÑÌñâÏ§ëÏù∏ Ï£ºÎ¨∏ Ï°∞Ìöå
 */

export function useGetInProgressOrders<TData = Awaited<ReturnType<typeof getInProgressOrders>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInProgressOrdersQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÜåÎπÑÏûêÍ∞Ä Î∞∞Îã¨ ÏôÑÎ£åÎêú Ï£ºÎ¨∏ ÎÇ¥Ïó≠ÏùÑ ÏöîÏ≤≠Ìïú Í≤ΩÏö∞
 * @summary Î∞∞Îã¨ ÏôÑÎ£åÎêú Ï£ºÎ¨∏ Ï°∞Ìöå
 */
export const getCompletedOrders = (params?: GetCompletedOrdersParams, signal?: AbortSignal) => {
  return customInstance<ApiResponseCursorPageResponseOrderResponse>({
    url: `/api/v1/customer/orders/completed`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetCompletedOrdersInfiniteQueryKey = (params?: GetCompletedOrdersParams) => {
  return ['infinate', `/api/v1/customer/orders/completed`, ...(params ? [params] : [])] as const;
};

export const getGetCompletedOrdersQueryKey = (params?: GetCompletedOrdersParams) => {
  return [`/api/v1/customer/orders/completed`, ...(params ? [params] : [])] as const;
};

export const getGetCompletedOrdersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCompletedOrdersInfiniteQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompletedOrders>>> = ({ signal }) =>
    getCompletedOrders(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCompletedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCompletedOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCompletedOrders>>>;
export type GetCompletedOrdersInfiniteQueryError = unknown;

export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params: undefined | GetCompletedOrdersParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î∞∞Îã¨ ÏôÑÎ£åÎêú Ï£ºÎ¨∏ Ï°∞Ìöå
 */

export function useGetCompletedOrdersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCompletedOrders>>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCompletedOrdersInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCompletedOrdersQueryOptions = <
  TData = Awaited<ReturnType<typeof getCompletedOrders>>,
  TError = unknown,
>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCompletedOrdersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompletedOrders>>> = ({ signal }) =>
    getCompletedOrders(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCompletedOrders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCompletedOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getCompletedOrders>>>;
export type GetCompletedOrdersQueryError = unknown;

export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params: undefined | GetCompletedOrdersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params?: GetCompletedOrdersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedOrders>>,
          TError,
          Awaited<ReturnType<typeof getCompletedOrders>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Î∞∞Îã¨ ÏôÑÎ£åÎêú Ï£ºÎ¨∏ Ï°∞Ìöå
 */

export function useGetCompletedOrders<TData = Awaited<ReturnType<typeof getCompletedOrders>>, TError = unknown>(
  params?: GetCompletedOrdersParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedOrders>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCompletedOrdersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
